module Conjure.Language.DomainSizeTest ( tests ) where

-- conjure
import Conjure.Prelude
import Conjure.Language.Constant
import Conjure.Language.Type
import Conjure.Language.Domain
import Conjure.Language.DomainSizeOf ( domainSizeOf )

-- tasty
import Test.Tasty ( TestTree, testGroup )
import Test.Tasty.HUnit ( testCase, (@?=) )


domainSizeConstant :: MonadFail m => Domain () Constant -> m Integer
domainSizeConstant = domainSizeOf

tests :: TestTree
tests = testGroup "domainSize"
    [ testCase "domain size of bool is 2" $
        domainSizeConstant DomainBool @?= Right 2
    , testCase "domain size of int(1..100)" $
<<<<<<< HEAD
        domainSizeConstant (DomainInt Nothing [RangeBounded (ConstantInt Nothing 1) (ConstantInt Nothing 100)]) @?= Right 100
||||||| merged common ancestors
        domainSizeConstant (DomainInt [RangeBounded (ConstantInt 1) (ConstantInt 100)]) @?= Right 100
=======
        domainSizeConstant (DomainInt NoTag [RangeBounded ((ConstantInt NoTag) 1) ((ConstantInt NoTag) 100)]) @?= Right 100
>>>>>>> taggedints
    , testCase "domain size of int(1,...,100)" $
<<<<<<< HEAD
        domainSizeConstant (DomainInt Nothing (map (RangeSingle . ConstantInt Nothing) [1 .. 100])) @?= Right 100
||||||| merged common ancestors
        domainSizeConstant (DomainInt (map (RangeSingle . ConstantInt) [1 .. 100])) @?= Right 100
=======
        domainSizeConstant (DomainInt NoTag (map (RangeSingle . (ConstantInt NoTag)) [1 .. 100])) @?= Right 100
>>>>>>> taggedints
    , testCase "domain size of int(13)" $
<<<<<<< HEAD
        domainSizeConstant (DomainInt Nothing [RangeSingle (ConstantInt Nothing 13)]) @?= Right 1
||||||| merged common ancestors
        domainSizeConstant (DomainInt [RangeSingle (ConstantInt 13)]) @?= Right 1
=======
        domainSizeConstant (DomainInt NoTag [RangeSingle ((ConstantInt NoTag) 13)]) @?= Right 1
>>>>>>> taggedints
    , testCase "domain size of int(13,1..100)" $
<<<<<<< HEAD
        domainSizeConstant (DomainInt Nothing [ RangeSingle (ConstantInt Nothing 13)
                                      , RangeBounded (ConstantInt Nothing 1) (ConstantInt Nothing 100)
||||||| merged common ancestors
        domainSizeConstant (DomainInt [ RangeSingle (ConstantInt 13)
                                      , RangeBounded (ConstantInt 1) (ConstantInt 100)
=======
        domainSizeConstant (DomainInt NoTag [ RangeSingle ((ConstantInt NoTag) 13)
                                      , RangeBounded ((ConstantInt NoTag) 1) ((ConstantInt NoTag) 100)
>>>>>>> taggedints
                                      ]) @?= Right 100
    , testCase "domain size of int(113,1..100)" $
<<<<<<< HEAD
        domainSizeConstant (DomainInt Nothing [ RangeSingle (ConstantInt Nothing 113)
                                      , RangeBounded (ConstantInt Nothing 1) (ConstantInt Nothing 100)
||||||| merged common ancestors
        domainSizeConstant (DomainInt [ RangeSingle (ConstantInt 113)
                                      , RangeBounded (ConstantInt 1) (ConstantInt 100)
=======
        domainSizeConstant (DomainInt NoTag [ RangeSingle ((ConstantInt NoTag) 113)
                                      , RangeBounded ((ConstantInt NoTag) 1) ((ConstantInt NoTag) 100)
>>>>>>> taggedints
                                      ]) @?= Right 101
    , testCase "domain size of set of bool #1" $
        domainSizeConstant (DomainSet () (SetAttr SizeAttr_None) DomainBool) @?= Right 4
    , testCase "domain size of set of bool #2" $
        let setOfSize n = DomainSet () (SetAttr (SizeAttr_Size n))
<<<<<<< HEAD
        in  domainSizeConstant (setOfSize (ConstantInt Nothing 2) DomainBool) @?= Right 1
||||||| merged common ancestors
        in  domainSizeConstant (setOfSize (ConstantInt 2) DomainBool) @?= Right 1
=======
        in  domainSizeConstant (setOfSize ((ConstantInt NoTag) 2) DomainBool) @?= Right 1
>>>>>>> taggedints
    ]

