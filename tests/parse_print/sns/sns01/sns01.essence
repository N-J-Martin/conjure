language Essence 1.4

letting RANGE be domain int(1..9)
letting VALUES be domain int(0..9)

given values : matrix indexed by [RANGE,RANGE] of VALUES

find field: matrix indexed by [RANGE, RANGE] of RANGE

$ find act1 : bool

$ neighbourhood row1 : (act1, [field[1,..]])

$ incumbentMapping ([field], [fieldshadow])

such that
  $ all rows have to be different
  forAll row : RANGE .
       allDiff(field[row,..]),

  $ all columns have to be different
  forAll col : RANGE .
       allDiff(field[..,col]),

  $ all 3x3 blocks have to be different
      forAll i,j : int(0..2) .
           forAll col1,col2,row1,row2 : int(1..3) .
           ((col1 != col2) /\ (row1 != row2)) ->
               (field[row1+(i*3), col1+(j*3)]
                                != field[row2+(i*3), col2+(j*3)]),

  $ we have to set some initial values
  forAll row,col : RANGE .
       (values[row,col] > 0) ->
               (field[row,col] = values[row,col]),







SNSGroup field1 : [field[1,..]]



SNSNeighbourhood row1 : (field1, n : int(1), such that true)


SNSNeighbourhood row1FirstHalf :
    ( field1
    , n : int(1)
    , such that forAll i : int(1..5) . incumbent(field[1,i]) = field[1,i]
    )

$ find activator_row1FirstHalf : bool
$ find shadowOf_field : ...
$ such that activator_row1FirstHalf ->
$               forAll i : int(1..5) field[1,i] = shadowOf_field[1,i]
$ neighbourhood row1FirstHalf : (activator_row1FirstHalf, [field[1,..]])


$ incumbentMapping ([field], [shadowOf_field])



$ neighbourhood row1FirstHalf :
$      (forAll i : int(1..5) . shadow_field[1,i] = field[1,i]
$      ,
$      [field[1,..]]
$         )
$


