$ conjure parameter-generator function.essence --essence-out function-gen.essence
Generating models for function-gen.essence
Generated models: model000001.eprime
Saved under: conjure-output
Savile Row: model000001.eprime test.param
Copying solution to: function-gen-test.solution
File: function-gen.essence
language Essence 1.3

given a_middle: int(1..10)
given a_delta: int(0..4)
find a: int(1..10)
such that
    a >= a_middle - a_delta,
    a <= a_middle + a_delta
given b_middle: int(1..10)
given b_delta: int(0..4)
find b: int(1..10)
such that
    b >= b_middle - b_delta,
    b <= b_middle + b_delta
given c_middle: int(1..10)
given c_delta: int(0..4)
find c: int(1..10)
such that
    c >= c_middle - c_delta,
    c <= c_middle + c_delta
given s_middle: int(1..10)
given s_delta: int(0..4)
find s: int(1..10)
such that
    s >= s_middle - s_delta,
    s <= s_middle + s_delta
given f_1_middle: int(1..10)
given f_1_delta: int(0..4)
given f_2_middle: int(1..100)
given f_2_delta: int(0..49)
find f: function (injective) int(1..10) --> int(1..100)
such that
    and([q1 >= a /\ q1 <= b <-> q1 in defined(f) | q1 : int(1..10)]),
    and([q1[1] >= f_1_middle - f_1_delta | q1 <- f]),
    and([q1[1] <= f_1_middle + f_1_delta | q1 <- f]),
    and([q1[1] >= a | q1 <- f]),
    and([q1[1] <= b | q1 <- f]),
    and([q1[2] >= f_2_middle - f_2_delta | q1 <- f]),
    and([q1[2] <= f_2_middle + f_2_delta | q1 <- f]),
    and([q1[2] >= c | q1 <- f])
given g_1_middle: int(1..10)
given g_1_delta: int(0..4)
given g_2_middle: int(1..100)
given g_2_delta: int(0..49)
find g: function (minSize 1, maxSize 10, injective) int(1..10) --> int(1..100)
such that
    |g| >= s,
    |g| <= s,
    and([q2[1] >= g_1_middle - g_1_delta | q2 <- g]),
    and([q2[1] <= g_1_middle + g_1_delta | q2 <- g]),
    and([q2[1] >= a | q2 <- g]),
    and([q2[1] <= b | q2 <- g]),
    and([q2[2] >= g_2_middle - g_2_delta | q2 <- g]),
    and([q2[2] <= g_2_middle + g_2_delta | q2 <- g]),
    and([q2[2] >= c | q2 <- g])
given h_1_middle: int(1..10)
given h_1_delta: int(0..4)
given h_2_middle: int(1..100)
given h_2_delta: int(0..49)
find h: function (minSize 1, injective) int(1..10) --> int(1..100)
such that
    |h| >= s,
    and([q3[1] >= h_1_middle - h_1_delta | q3 <- h]),
    and([q3[1] <= h_1_middle + h_1_delta | q3 <- h]),
    and([q3[1] >= a | q3 <- h]),
    and([q3[1] <= b | q3 <- h]),
    and([q3[2] >= h_2_middle - h_2_delta | q3 <- h]),
    and([q3[2] <= h_2_middle + h_2_delta | q3 <- h]),
    and([q3[2] >= c | q3 <- h])
such that g != h

--------------------


File: function-gen.essence.irace
a_middle "-a_middle " i (1, 10)
a_delta "-a_delta " i (0, 4)
b_middle "-b_middle " i (1, 10)
b_delta "-b_delta " i (0, 4)
c_middle "-c_middle " i (1, 10)
c_delta "-c_delta " i (0, 4)
s_middle "-s_middle " i (1, 10)
s_delta "-s_delta " i (0, 4)
f_1_middle "-f_1_middle " i (1, 10)
f_1_delta "-f_1_delta " i (0, 4)
f_2_middle "-f_2_middle " i (1, 100)
f_2_delta "-f_2_delta " i (0, 49)
g_1_middle "-g_1_middle " i (1, 10)
g_1_delta "-g_1_delta " i (0, 4)
g_2_middle "-g_2_middle " i (1, 100)
g_2_delta "-g_2_delta " i (0, 49)
h_1_middle "-h_1_middle " i (1, 10)
h_1_delta "-h_1_delta " i (0, 4)
h_2_middle "-h_2_middle " i (1, 100)
h_2_delta "-h_2_delta " i (0, 49)
--------------------


File: function-gen-test.solution
language Essence 1.3

letting a be 4
letting b be 7
letting c be 9
letting f be function(4 --> 9, 5 --> 10, 6 --> 11, 7 --> 12)
letting g be function(5 --> 9, 6 --> 10, 7 --> 11)
letting h be function(5 --> 9, 6 --> 10, 7 --> 12)
letting s be 3

--------------------


$ conjure parameter-generator function.essence --essence-out function-gen.essence --MININT -10 --MAXINT 50
Generating models for function-gen.essence
Generated models: model000001.eprime
Saved under: conjure-output
Savile Row: model000001.eprime test.param
Copying solution to: function-gen-test.solution
File: function-gen.essence
language Essence 1.3

given a_middle: int(1..10)
given a_delta: int(0..4)
find a: int(1..10)
such that
    a >= a_middle - a_delta,
    a <= a_middle + a_delta
given b_middle: int(1..10)
given b_delta: int(0..4)
find b: int(1..10)
such that
    b >= b_middle - b_delta,
    b <= b_middle + b_delta
given c_middle: int(1..10)
given c_delta: int(0..4)
find c: int(1..10)
such that
    c >= c_middle - c_delta,
    c <= c_middle + c_delta
given s_middle: int(1..10)
given s_delta: int(0..4)
find s: int(1..10)
such that
    s >= s_middle - s_delta,
    s <= s_middle + s_delta
given f_1_middle: int(1..10)
given f_1_delta: int(0..4)
given f_2_middle: int(1..50)
given f_2_delta: int(0..24)
find f: function (injective) int(1..10) --> int(1..50)
such that
    and([q1 >= a /\ q1 <= b <-> q1 in defined(f) | q1 : int(1..10)]),
    and([q1[1] >= f_1_middle - f_1_delta | q1 <- f]),
    and([q1[1] <= f_1_middle + f_1_delta | q1 <- f]),
    and([q1[1] >= a | q1 <- f]),
    and([q1[1] <= b | q1 <- f]),
    and([q1[2] >= f_2_middle - f_2_delta | q1 <- f]),
    and([q1[2] <= f_2_middle + f_2_delta | q1 <- f]),
    and([q1[2] >= c | q1 <- f])
given g_1_middle: int(1..10)
given g_1_delta: int(0..4)
given g_2_middle: int(1..50)
given g_2_delta: int(0..24)
find g: function (minSize 1, maxSize 10, injective) int(1..10) --> int(1..50)
such that
    |g| >= s,
    |g| <= s,
    and([q2[1] >= g_1_middle - g_1_delta | q2 <- g]),
    and([q2[1] <= g_1_middle + g_1_delta | q2 <- g]),
    and([q2[1] >= a | q2 <- g]),
    and([q2[1] <= b | q2 <- g]),
    and([q2[2] >= g_2_middle - g_2_delta | q2 <- g]),
    and([q2[2] <= g_2_middle + g_2_delta | q2 <- g]),
    and([q2[2] >= c | q2 <- g])
given h_1_middle: int(1..10)
given h_1_delta: int(0..4)
given h_2_middle: int(1..50)
given h_2_delta: int(0..24)
find h: function (minSize 1, injective) int(1..10) --> int(1..50)
such that
    |h| >= s,
    and([q3[1] >= h_1_middle - h_1_delta | q3 <- h]),
    and([q3[1] <= h_1_middle + h_1_delta | q3 <- h]),
    and([q3[1] >= a | q3 <- h]),
    and([q3[1] <= b | q3 <- h]),
    and([q3[2] >= h_2_middle - h_2_delta | q3 <- h]),
    and([q3[2] <= h_2_middle + h_2_delta | q3 <- h]),
    and([q3[2] >= c | q3 <- h])
such that g != h

--------------------


File: function-gen.essence.irace
a_middle "-a_middle " i (1, 10)
a_delta "-a_delta " i (0, 4)
b_middle "-b_middle " i (1, 10)
b_delta "-b_delta " i (0, 4)
c_middle "-c_middle " i (1, 10)
c_delta "-c_delta " i (0, 4)
s_middle "-s_middle " i (1, 10)
s_delta "-s_delta " i (0, 4)
f_1_middle "-f_1_middle " i (1, 10)
f_1_delta "-f_1_delta " i (0, 4)
f_2_middle "-f_2_middle " i (1, 50)
f_2_delta "-f_2_delta " i (0, 24)
g_1_middle "-g_1_middle " i (1, 10)
g_1_delta "-g_1_delta " i (0, 4)
g_2_middle "-g_2_middle " i (1, 50)
g_2_delta "-g_2_delta " i (0, 24)
h_1_middle "-h_1_middle " i (1, 10)
h_1_delta "-h_1_delta " i (0, 4)
h_2_middle "-h_2_middle " i (1, 50)
h_2_delta "-h_2_delta " i (0, 24)
--------------------


File: function-gen-test.solution
language Essence 1.3

letting a be 4
letting b be 7
letting c be 9
letting f be function(4 --> 9, 5 --> 10, 6 --> 11, 7 --> 12)
letting g be function(5 --> 9, 6 --> 10, 7 --> 11)
letting h be function(5 --> 9, 6 --> 10, 7 --> 12)
letting s be 3

--------------------


