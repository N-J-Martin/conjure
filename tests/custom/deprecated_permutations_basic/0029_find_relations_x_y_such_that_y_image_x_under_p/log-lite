Command line options:  Modelling {essence = "permutation.essence", outputDirectory = "conjure-output", numberingStart = 1, smartFilenames = False, responses = "", logLevel = LogDebug, verboseTrail = False, rewritesTrail = False, logRuleFails = False, logRuleSuccesses = False, logRuleAttempts = False, logChoices = False, strategyQ = "f", strategyA = "ai", representations = Nothing, representationsFinds = Nothing, representationsGivens = Nothing, representationsAuxiliaries = Nothing, representationsQuantifieds = Nothing, representationsCuts = Nothing, channelling = True, representationLevels = True, seed = Nothing, limitModels = Nothing, limitTime = Nothing, savedChoices = Nothing, outputFormat = Plain, lineWidth = 120}
[input]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    
[removeUnnamedsFromModel]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    
Recording enumGivens:
[removeEnumsFromModel]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    
[resolveNames]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    
[typeCheckModel]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    
[categoryChecking]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    
[sanityChecks]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    
[typeCheckModel]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    
[input]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    
[addSearchOrder]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[attributeAsConstraints]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[inferAttributes]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[inlineLettingDomainsForDecls]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[lettingsForComplexInDoms]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[distinctQuantifiedVars]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[initInfo]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[removeUnnamedsFromModel]
    language Essence 1.3
    
    letting MYTYPE be new type enum {THING1, THING2, THING3, THING4, THING5}
    letting p be permutation((THING3, THING4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
Recording enumGivens:
[removeEnumsFromModel]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[finiteGivens]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (MYTYPE * MYTYPE)
    find y: relation (size 4) of (MYTYPE * MYTYPE)
    such that y = image(p, x)
    branching on [x, y]
    
[resolveNames]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[initInfo_Lettings]
    language Essence 1.3
    
    letting MYTYPE be domain int(1..5)
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[removeDomainLettings]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[typeCheckModel]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[categoryChecking]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[sanityChecks]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    
[dealWithCuts]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    such that
    
[removeExtraSlices]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    such that
    
[addTrueConstraints]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that y = image(p, x)
    branching on [x, y]
    such that
    such that
        true(x),
        true(y)
    
Contains 0 parameters         (0 abstract)
         2 decision variables (2 abstract)
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(p, x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        
Picking the first option: Question 1: permutation((3, 4))
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   permutation((3, 4))
storedChoice:
permutation((3, 4)) -604127175528974338
AnsweredRule {qHole_ = -604127175528974338, qAscendants_ = fromList [], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[],"qHole_":-604127175528974338}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(p, x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        
Picking the first option: Question 1: p
                              Context #1: image(p, x)
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   permutation((3, 4))
storedChoice:
p -7234408895829330219
AnsweredRule {qHole_ = -7234408895829330219, qAscendants_ = fromList [-7340749217212310711,-5834110796085551311], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-7340749217212310711,-5834110796085551311],"qHole_":-7234408895829330219}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        
Picking the first option: Question 1: x
                              Context #1: image(permutation((3, 4)), x)
Picking the only option: Answer 1: choose-repr: Choosing representation for x:
                                                    relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))
                                   x
storedChoice:
x -7234408895963551171
AnsweredReprStored {qHole_ = -7234408895963551171, qAscendants_ = fromList [-7111069252946253414,-6043361806322913446], aDomStored_ = "relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))", aRuleName_ = "choose-repr"}
LF:  {"AnsweredReprStored":{"aDomStored_":"relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))","aRuleName_":"choose-repr","qAscendants_":[-7111069252946253414,-6043361806322913446],"qHole_":-7234408895963551171}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        
Picking the first option: Question 1: y
                              Context #1: y = image(permutation((3, 4)), x)
Picking the only option: Answer 1: choose-repr: Choosing representation for y:
                                                    relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))
                                   y
storedChoice:
y -7234408895946773554
AnsweredReprStored {qHole_ = -7234408895946773554, qAscendants_ = fromList [-7111069252946253414], aDomStored_ = "relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))", aRuleName_ = "choose-repr"}
LF:  {"AnsweredReprStored":{"aDomStored_":"relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))","aRuleName_":"choose-repr","qAscendants_":[-7111069252946253414],"qHole_":-7234408895946773554}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: x
                              Context #1: true(x)
Picking the only option: Answer 1: choose-repr: Choosing representation for x:
                                                    relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))
                                   x
storedChoice:
x -7234408895963551171
AnsweredReprStored {qHole_ = -7234408895963551171, qAscendants_ = fromList [-1508832156878423928], aDomStored_ = "relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))", aRuleName_ = "choose-repr"}
LF:  {"AnsweredReprStored":{"aDomStored_":"relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))","aRuleName_":"choose-repr","qAscendants_":[-1508832156878423928],"qHole_":-7234408895963551171}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: y
                              Context #1: true(y)
Picking the only option: Answer 1: choose-repr: Choosing representation for y:
                                                    relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))
                                   y
storedChoice:
y -7234408895946773554
AnsweredReprStored {qHole_ = -7234408895946773554, qAscendants_ = fromList [-1508550667338902379], aDomStored_ = "relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))", aRuleName_ = "choose-repr"}
LF:  {"AnsweredReprStored":{"aDomStored_":"relation {RelationAsMatrix} (size 4) of (int(1..5) * int(1..5))","aRuleName_":"choose-repr","qAscendants_":[-1508550667338902379],"qHole_":-7234408895946773554}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)]
                              Context #1: sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q1 (with type: int)
                                   [sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)]
storedChoice:
[sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)] 6263396600925448594
AnsweredRule {qHole_ = 6263396600925448594, qAscendants_ = fromList [5049395136776340146,5865511705196666561], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[5049395136776340146,5865511705196666561],"qHole_":6263396600925448594}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]
                              Context #1: sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q2 (with type: int)
                                   [toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]
storedChoice:
[toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)] 7855671108991671235
AnsweredRule {qHole_ = 7855671108991671235, qAscendants_ = fromList [5049395136776340146,5865511705196666561,6263396600925448594,7085372780514568240], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[5049395136776340146,5865511705196666561,6263396600925448594,7085372780514568240],"qHole_":7855671108991671235}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)]
                              Context #1: sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q3 (with type: int)
                                   [sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)]
storedChoice:
[sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)] -3620919297952344383
AnsweredRule {qHole_ = -3620919297952344383, qAscendants_ = fromList [-5513655157779400708,7219712989341858895], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-5513655157779400708,7219712989341858895],"qHole_":-3620919297952344383}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]
                              Context #1: sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q4 (with type: int)
                                   [toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]
storedChoice:
[toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)] -2356590267706027710
AnsweredRule {qHole_ = -2356590267706027710, qAscendants_ = fromList [-5513655157779400708,-3620919297952344383,7219712989341858895,8125267169441206107], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-5513655157779400708,-3620919297952344383,7219712989341858895,8125267169441206107],"qHole_":-2356590267706027710}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that y = image(permutation((3, 4)), x)
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: image(permutation((3, 4)), x)
                              Context #1: y = image(permutation((3, 4)), x)
Picking the only option: Answer 1: relation-image: Horizontal rule for image relation in comprehension
                                   { conjure_aux1
                                   @ find conjure_aux1: relation (size 4) of (int(1..5) * int(1..5))
                                     such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
                                   }
storedChoice:
image(permutation((3, 4)), x) -6043361806322913446
AnsweredRule {qHole_ = -6043361806322913446, qAscendants_ = fromList [-7111069252946253414], aRuleName_ = "relation-image"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-image","qAscendants_":[-7111069252946253414],"qHole_":-6043361806322913446}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1: relation (size 4) of (int(1..5) * int(1..5))
              such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { conjure_aux1
                                      @ find conjure_aux1: relation (size 4) of (int(1..5) * int(1..5))
                                        such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
                                      }
                              Context #1: y =
                                          { conjure_aux1
                                          @ find conjure_aux1: relation (size 4) of (int(1..5) * int(1..5))
                                            such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
                                          }
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux1
                                   { conjure_aux1
                                   @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                     such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                     such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
                                   }
storedChoice:
{ conjure_aux1
@ find conjure_aux1: relation (size 4) of (int(1..5) * int(1..5))
  such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
} 1714623876200418132
AnsweredRule {qHole_ = 1714623876200418132, qAscendants_ = fromList [5536329259437519582], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[5536329259437519582],"qHole_":1714623876200418132}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)]
                              Context #1: sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q6 (with type: int)
                                   [sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)]
storedChoice:
[sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)] -878601234175159627
AnsweredRule {qHole_ = -878601234175159627, qAscendants_ = fromList [-5775367836057753714,-1245214478984509661,79132428954328345,1049837485042621691], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-5775367836057753714,-1245214478984509661,79132428954328345,1049837485042621691],"qHole_":-878601234175159627}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]
                              Context #1: sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q7 (with type: int)
                                   [toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]
storedChoice:
[toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)] 2379582110528111197
AnsweredRule {qHole_ = 2379582110528111197, qAscendants_ = fromList [-5775367836057753714,-1245214478984509661,-878601234175159627,79132428954328345,1049837485042621691,4483484998279672051], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-5775367836057753714,-1245214478984509661,-878601234175159627,79132428954328345,1049837485042621691,4483484998279672051],"qHole_":2379582110528111197}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that |x| = |conjure_aux1| /\ and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x]
                              Context #1: and([image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x])
Picking the only option: Answer 1: relation-map_in_expr{RelationAsMatrix}: Vertical rule for map_in_expr for relation domains, RelationAsMatrix representation.
                                   [image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1 | q8 : (int(1..5), int(1..5)), x_RelationAsMatrix[q8[1], q8[2]]]
storedChoice:
[image(permutation((3, 4)), q5) in conjure_aux1 | q5 <- x] 2569794631160861273
AnsweredRule {qHole_ = 2569794631160861273, qAscendants_ = fromList [-4776664362067532454,-1245214478984509661,-1036657270873470960,79132428954328345,5830139973578569810], aRuleName_ = "relation-map_in_expr{RelationAsMatrix}"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-map_in_expr{RelationAsMatrix}","qAscendants_":[-4776664362067532454,-1245214478984509661,-1036657270873470960,79132428954328345,5830139973578569810],"qHole_":2569794631160861273}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1 | q8 : (int(1..5), int(1..5)), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1
                                           | q8 : (int(1..5), int(1..5)), x_RelationAsMatrix[q8[1], q8[2]]]
                              Context #1: and([image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1
                                                   | q8 : (int(1..5), int(1..5)), x_RelationAsMatrix[q8[1], q8[2]]])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q8 (with type: (int,
                                                                                                                                  int))
                                   [image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]]
storedChoice:
[image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1
     | q8 : (int(1..5), int(1..5)), x_RelationAsMatrix[q8[1], q8[2]]] -6121410142271556240
AnsweredRule {qHole_ = -6121410142271556240, qAscendants_ = fromList [-8542780548609610841,-2372866271326699518,-688805377682383984,1829424135801856670,4203509818187934421], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-8542780548609610841,-2372866271326699518,-688805377682383984,1829424135801856670,4203509818187934421],"qHole_":-6121410142271556240}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: image(permutation((3, 4)), (q8[1], q8[2]))
                              Context #1: image(permutation((3, 4)), (q8[1], q8[2])) in conjure_aux1
Picking the only option: Answer 1: tuple-image: Horizontal rule for image tuple in comprehension
                                   { conjure_aux2
                                   @ find conjure_aux2: (int(1..5), int(1..5))
                                     such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                                     such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                                   }
storedChoice:
image(permutation((3, 4)), (q8[1], q8[2])) 7641797427128728383
AnsweredRule {qHole_ = 7641797427128728383, qAscendants_ = fromList [-6118234929664435696,-1399392580596120430,-1387706708486858898,-1208703870972871253,-742133995496027829,4437220630107512706,5070918677941821273], aRuleName_ = "tuple-image"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-image","qAscendants_":[-6118234929664435696,-1399392580596120430,-1387706708486858898,-1208703870972871253,-742133995496027829,4437220630107512706,5070918677941821273],"qHole_":7641797427128728383}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2: (int(1..5), int(1..5))
                         such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { conjure_aux2
                                      @ find conjure_aux2: (int(1..5), int(1..5))
                                        such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                                        such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                                      }
                              Context #1: { conjure_aux2
                                          @ find conjure_aux2: (int(1..5), int(1..5))
                                            such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                                            such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                                          }
                                          in conjure_aux1
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux2
                                   { conjure_aux2
                                   @ find conjure_aux2_1: int(1..5)
                                     find conjure_aux2_2: int(1..5)
                                     such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                                     such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                                   }
storedChoice:
{ conjure_aux2
@ find conjure_aux2: (int(1..5), int(1..5))
  such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
  such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
} 7832450608952021018
AnsweredRule {qHole_ = 7832450608952021018, qAscendants_ = fromList [-4717314876217502109,-4294582922489450379,1651264905194084305,2977457561748621690,4087019737558016944,5019534480518702783,6820345709468359473], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-4717314876217502109,-4294582922489450379,1651264905194084305,2977457561748621690,4087019737558016944,5019534480518702783,6820345709468359473],"qHole_":7832450608952021018}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: conjure_aux2[1]
                              Context #1: conjure_aux2[1] = image(permutation((3, 4)), (q8[1], q8[2])[1])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: conjure_aux2[1]
                                   conjure_aux2_1
storedChoice:
conjure_aux2[1] 2042848205583864547
AnsweredRule {qHole_ = 2042848205583864547, qAscendants_ = fromList [-7836606021998938252,-4083899676628141502,-3337431591692655861,-1871379374487492755,31163859450310923,347176683161250196,1078578095348213584,3723112517704369347,8818185052449544140], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-7836606021998938252,-4083899676628141502,-3337431591692655861,-1871379374487492755,31163859450310923,347176683161250196,1078578095348213584,3723112517704369347,8818185052449544140],"qHole_":2042848205583864547}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that conjure_aux2_1 = image(permutation((3, 4)), (q8[1], q8[2])[1])
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: (q8[1], q8[2])[1]
                              Context #1: image(permutation((3, 4)), (q8[1], q8[2])[1])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: (q8[1], q8[2])[1]
                                   q8[1]
storedChoice:
(q8[1], q8[2])[1] -5501922928837560372
AnsweredRule {qHole_ = -5501922928837560372, qAscendants_ = fromList [-8079003502337880871,-5992757738829033069,-4052786222025792276,-4045994663639704708,-1887930543228865818,2614825847120268012,2969550575619082812,4897364746913734457,7503648025096004321,8070588202073729915], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8079003502337880871,-5992757738829033069,-4052786222025792276,-4045994663639704708,-1887930543228865818,2614825847120268012,2969550575619082812,4897364746913734457,7503648025096004321,8070588202073729915],"qHole_":-5501922928837560372}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that conjure_aux2_1 = image(permutation((3, 4)), q8[1])
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q8[1]
                              Context #1: image(permutation((3, 4)), q8[1])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q8[1]
                                   q8_1
storedChoice:
q8[1] 6051865069970393497
AnsweredRule {qHole_ = 6051865069970393497, qAscendants_ = fromList [-6240564754428641774,-3828924106000349868,-2497616537930163555,-2455337427536589680,-1546470019878997061,409221243111017286,1096079797629796883,1353067250173028676,4249511820642706384,6954638962073438443], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-6240564754428641774,-3828924106000349868,-2497616537930163555,-2455337427536589680,-1546470019878997061,409221243111017286,1096079797629796883,1353067250173028676,4249511820642706384,6954638962073438443],"qHole_":6051865069970393497}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that conjure_aux2_1 = image(permutation((3, 4)), q8_1)
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: image(permutation((3, 4)), q8_1)
                              Context #1: conjure_aux2_1 = image(permutation((3, 4)), q8_1)
Picking the only option: Answer 1: permutation-image-literal{AsFunction}: Horizontal rule for permutation literal application to a single value (image), AsFunction representation
                                   { conjure_aux3
                                   @ find conjure_aux3: int(1..5)
                                     such that
                                         and([q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                         (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                                   }
storedChoice:
image(permutation((3, 4)), q8_1) -6565377216106402436
AnsweredRule {qHole_ = -6565377216106402436, qAscendants_ = fromList [-8683446058401842621,-8501667396727033866,-6589174251984098358,-5196229448616722462,-2562107481961042620,-1290778481550223845,5400239128163960843,7319032080622836357,8711639898256895276], aRuleName_ = "permutation-image-literal{AsFunction}"}
LF:  {"AnsweredRule":{"aRuleName_":"permutation-image-literal{AsFunction}","qAscendants_":[-8683446058401842621,-8501667396727033866,-6589174251984098358,-5196229448616722462,-2562107481961042620,-1290778481550223845,5400239128163960843,7319032080622836357,8711639898256895276],"qHole_":-6565377216106402436}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and([q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [(3, 4), (4, 3); int(1..2)]
                              Context #1: [q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   [(3, 4), (4, 3); int(1..2)]
storedChoice:
[(3, 4), (4, 3); int(1..2)] 6597397470067790033
AnsweredRule {qHole_ = 6597397470067790033, qAscendants_ = fromList [-8621354921797967448,-6160248818055544346,-6049820697610812758,-4894284809815571873,-4858508204008314707,-4635274203177452231,-1665058964617223774,996353907888938120,1107585814561782716,1593343993162845666,1994644797538381771,2641311773319376803,3730217346423440641,5862930277568425410], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8621354921797967448,-6160248818055544346,-6049820697610812758,-4894284809815571873,-4858508204008314707,-4635274203177452231,-1665058964617223774,996353907888938120,1107585814561782716,1593343993162845666,1994644797538381771,2641311773319376803,3730217346423440641,5862930277568425410],"qHole_":6597397470067790033}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and([q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: and([q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: complex-pattern: complex pattern on tuple patterns
                                   [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | q13 <- [(3, 4), (4, 3); int(1..2)]]
storedChoice:
[q9 = q8_1 <-> conjure_aux3 = q10 | (q9, q10) <- [(3, 4), (4, 3); int(1..2)]] 996353907888938120
AnsweredRule {qHole_ = 996353907888938120, qAscendants_ = fromList [-8621354921797967448,-6160248818055544346,-6049820697610812758,-4894284809815571873,-4858508204008314707,-4635274203177452231,-1665058964617223774,1107585814561782716,1593343993162845666,1994644797538381771,2641311773319376803,3730217346423440641,5862930277568425410], aRuleName_ = "complex-pattern"}
LF:  {"AnsweredRule":{"aRuleName_":"complex-pattern","qAscendants_":[-8621354921797967448,-6160248818055544346,-6049820697610812758,-4894284809815571873,-4858508204008314707,-4635274203177452231,-1665058964617223774,1107585814561782716,1593343993162845666,1994644797538381771,2641311773319376803,3730217346423440641,5862930277568425410],"qHole_":996353907888938120}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and([q13[1] = q8_1 <-> conjure_aux3 = q13[2] | q13 <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | q13 <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: and([q13[1] = q8_1 <-> conjure_aux3 = q13[2] | q13 <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: matrix-comprehension-literal: Vertical rule for matrix-comprehension on matrix literal
                                   flatten(1,
                                           [[q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (3, 4)],
                                            [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (4, 3)];
                                                int(1..2)])
storedChoice:
[q13[1] = q8_1 <-> conjure_aux3 = q13[2] | q13 <- [(3, 4), (4, 3); int(1..2)]] 3456861798216985162
AnsweredRule {qHole_ = 3456861798216985162, qAscendants_ = fromList [-8808315865059383030,-8227483119145124211,-7793095449913038876,-5679502255425066053,-3572216896086163269,-3021143752573374113,-2561056581393168238,-842750970546105960,3371366859945964624,5522715912807809257,6264069036653869010,7196566142350255202,8156173651558168583], aRuleName_ = "matrix-comprehension-literal"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-literal","qAscendants_":[-8808315865059383030,-8227483119145124211,-7793095449913038876,-5679502255425066053,-3572216896086163269,-3021143752573374113,-2561056581393168238,-842750970546105960,3371366859945964624,5522715912807809257,6264069036653869010,7196566142350255202,8156173651558168583],"qHole_":3456861798216985162}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (3, 4)],
                                                [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q13[1]
                              Context #1: q13[1] = q8_1
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q13[1] -1254902052079317740
AnsweredRule {qHole_ = -1254902052079317740, qAscendants_ = fromList [-7844826506044189197,-6543998516580374433,-5468160839539146108,-4646329838907093569,-4421494240673914403,-4030269164244882685,-3696611495810109143,-3345198454859526376,-2923685885462842550,-2579765278873905792,-2489053689031557395,-2037117675633093401,-1199749775392010500,-1159821892128975232,-61377228416248265,964892601978301791,3910121320990104243,4511388692183383834], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-7844826506044189197,-6543998516580374433,-5468160839539146108,-4646329838907093569,-4421494240673914403,-4030269164244882685,-3696611495810109143,-3345198454859526376,-2923685885462842550,-2579765278873905792,-2489053689031557395,-2037117675633093401,-1199749775392010500,-1159821892128975232,-61377228416248265,964892601978301791,3910121320990104243,4511388692183383834],"qHole_":-1254902052079317740}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (3, 4)], [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q13[2]
                              Context #1: conjure_aux3 = q13[2]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q13[2] -1254620565291325713
AnsweredRule {qHole_ = -1254620565291325713, qAscendants_ = fromList [-8360775170969626109,-8218634654132870929,-7641638248746524641,-4934801957947094136,-4254522952928052133,-4092969587983186253,-3780104048260027650,-2622265047463603714,-848316662104045049,563172654367211215,1222024046659559696,4078666449752848978,4662787952378127984,5249190568318080416,5574891365015849631,7061285353711906011,7866305697050141526,9112935851435552216], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8360775170969626109,-8218634654132870929,-7641638248746524641,-4934801957947094136,-4254522952928052133,-4092969587983186253,-3780104048260027650,-2622265047463603714,-848316662104045049,563172654367211215,1222024046659559696,4078666449752848978,4662787952378127984,5249190568318080416,5574891365015849631,7061285353711906011,7866305697050141526,9112935851435552216],"qHole_":-1254620565291325713}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [q13[1] = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q13[1]
                              Context #1: q13[1] = q8_1
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q13[1] -1254902052079317740
AnsweredRule {qHole_ = -1254902052079317740, qAscendants_ = fromList [-8638629789947627417,-7681680422406975063,-7045052392114671596,-5468160839539146108,-5360000098558189830,-5130716656066417701,-3536433963763386607,-3341254942655847808,-1332675206370029612,-61377228416248265,518672155518189655,1368815305078223764,1506712726218393853,2813413964084179331,4256368997522955231,6094767248156078778,6822727452915095676,7566490689068664978], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8638629789947627417,-7681680422406975063,-7045052392114671596,-5468160839539146108,-5360000098558189830,-5130716656066417701,-3536433963763386607,-3341254942655847808,-1332675206370029612,-61377228416248265,518672155518189655,1368815305078223764,1506712726218393853,2813413964084179331,4256368997522955231,6094767248156078778,6822727452915095676,7566490689068664978],"qHole_":-1254902052079317740}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = q13[2] | letting q13 be (4, 3)]; int(1..2)]))
                                   /\ (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q13[2]
                              Context #1: conjure_aux3 = q13[2]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q13[2] -1254620565291325713
AnsweredRule {qHole_ = -1254620565291325713, qAscendants_ = fromList [-8870698451967212431,-8218634654132870929,-8157916199347819983,-6958532007910279584,-4735583185965836928,-3733766703817256233,-1365219118307736560,-1326414908464043218,-756643065960997164,-238771092705033653,525451447959791552,2934402913780861128,4090216973995379955,4246953395184334158,4325482688218662469,4385767247150328058,4926105801959606859,4926669858781506740], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8870698451967212431,-8218634654132870929,-8157916199347819983,-6958532007910279584,-4735583185965836928,-3733766703817256233,-1365219118307736560,-1326414908464043218,-756643065960997164,-238771092705033653,525451447959791552,2934402913780861128,4090216973995379955,4246953395184334158,4325482688218662469,4385767247150328058,4926105801959606859,4926669858781506740],"qHole_":-1254620565291325713}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3 | letting q13 be (4, 3)]; int(1..2)]))
                                   /\ (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = q8_1 <-> conjure_aux3 = 3 | letting q13 be (4, 3)]
                              Context #1: [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3 | letting q13 be (4, 3)];
                                               int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [4 = q8_1 <-> conjure_aux3 = 3 |]
storedChoice:
[4 = q8_1 <-> conjure_aux3 = 3 | letting q13 be (4, 3)] 7815870421468516721
AnsweredRule {qHole_ = 7815870421468516721, qAscendants_ = fromList [-7319924227898755161,-6204074559855855953,-5721547888581640964,-4667135429861035401,-3119038628659086386,-2914873009721382719,-275708737112837829,358797451837378,588328580564008008,1171576539747863800,3860402082075414220,5255108035061878259,7534557817041195235,8046872103256922185,9076826399099772257], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-7319924227898755161,-6204074559855855953,-5721547888581640964,-4667135429861035401,-3119038628659086386,-2914873009721382719,-275708737112837829,358797451837378,588328580564008008,1171576539747863800,3860402082075414220,5255108035061878259,7534557817041195235,8046872103256922185,9076826399099772257],"qHole_":7815870421468516721}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3 |]; int(1..2)])) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = q8_1 <-> conjure_aux3 = 3 |]
                              Context #1: [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3 |]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [4 = q8_1 <-> conjure_aux3 = 3; int(1)]
storedChoice:
[4 = q8_1 <-> conjure_aux3 = 3 |] 2538271587388693524
AnsweredRule {qHole_ = 2538271587388693524, qAscendants_ = fromList [-8521000068701228812,-8466935177678778299,-8378067175040646304,-7795155064905057512,-7398425908569645990,-5020343327513684658,-1331085484917687815,-382563719840663416,1239306329275872739,3167048961433864186,4591749041469508459,5482352134908236922,5648481728193344963,6702522234416193183,8765316459520566910], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8521000068701228812,-8466935177678778299,-8378067175040646304,-7795155064905057512,-7398425908569645990,-5020343327513684658,-1331085484917687815,-382563719840663416,1239306329275872739,3167048961433864186,4591749041469508459,5482352134908236922,5648481728193344963,6702522234416193183,8765316459520566910],"qHole_":2538271587388693524}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)]
                              Context #1: [[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [3 = q8_1 <-> conjure_aux3 = 4 |]
storedChoice:
[3 = q8_1 <-> conjure_aux3 = 4 | letting q13 be (3, 4)] 1317873634227795931
AnsweredRule {qHole_ = 1317873634227795931, qAscendants_ = fromList [-6229747794032826968,-5833692553090476381,-4830840744837226265,-4695719515395703877,-1447797878088113254,-1026424407203100673,-114180086101386755,1230900640119672810,2384858822123183656,2641682090906853361,4932647657883680462,5503876696275907482,5561643139389034608,8062918047402720448,8618709991360516938], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-6229747794032826968,-5833692553090476381,-4830840744837226265,-4695719515395703877,-1447797878088113254,-1026424407203100673,-114180086101386755,1230900640119672810,2384858822123183656,2641682090906853361,4932647657883680462,5503876696275907482,5561643139389034608,8062918047402720448,8618709991360516938],"qHole_":1317873634227795931}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4 |], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = q8_1 <-> conjure_aux3 = 4 |]
                              Context #1: [[3 = q8_1 <-> conjure_aux3 = 4 |], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [3 = q8_1 <-> conjure_aux3 = 4; int(1)]
storedChoice:
[3 = q8_1 <-> conjure_aux3 = 4 |] 7527005283398106432
AnsweredRule {qHole_ = 7527005283398106432, qAscendants_ = fromList [-5151808191572404398,-4353286235323785771,-4339955062448219396,-4142041909263092979,-3736320932349712947,-3440388200198466301,-2029225889893250969,-1817262023712192284,-116834249900757749,483550512093615086,1497957860809309721,2283573903554163553,3854374349353612498,7382215623493355130,8339321953980948829], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-5151808191572404398,-4353286235323785771,-4339955062448219396,-4142041909263092979,-3736320932349712947,-3440388200198466301,-2029225889893250969,-1817262023712192284,-116834249900757749,483550512093615086,1497957860809309721,2283573903554163553,3854374349353612498,7382215623493355130,8339321953980948829],"qHole_":7527005283398106432}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [(3, 4), (4, 3); int(1..2)]
                              Context #1: [q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   [(3, 4), (4, 3); int(1..2)]
storedChoice:
[(3, 4), (4, 3); int(1..2)] 6597397470067790033
AnsweredRule {qHole_ = 6597397470067790033, qAscendants_ = fromList [-9213624152780173787,-5982135693274236766,-5396430067534345835,-2363572399258163690,-2255081376624876153,-320252043164433323,1280603170430058832,2648872121679578871,4076507060053755550,5033554600497872881,6390584767367481427,6475772422542545541,6480002864764397731,6871118355510909196,7049518756068236715,8591929121087659168], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-9213624152780173787,-5982135693274236766,-5396430067534345835,-2363572399258163690,-2255081376624876153,-320252043164433323,1280603170430058832,2648872121679578871,4076507060053755550,5033554600497872881,6390584767367481427,6475772422542545541,6480002864764397731,6871118355510909196,7049518756068236715,8591929121087659168],"qHole_":6597397470067790033}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: or([q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: complex-pattern: complex pattern on tuple patterns
                                   [q14[1] = conjure_aux3 | q14 <- [(3, 4), (4, 3); int(1..2)]]
storedChoice:
[q11 = conjure_aux3 | (q11, q12) <- [(3, 4), (4, 3); int(1..2)]] 5033554600497872881
AnsweredRule {qHole_ = 5033554600497872881, qAscendants_ = fromList [-9213624152780173787,-5982135693274236766,-5396430067534345835,-2363572399258163690,-2255081376624876153,-320252043164433323,1280603170430058832,2648872121679578871,4076507060053755550,6390584767367481427,6475772422542545541,6480002864764397731,6871118355510909196,7049518756068236715,8591929121087659168], aRuleName_ = "complex-pattern"}
LF:  {"AnsweredRule":{"aRuleName_":"complex-pattern","qAscendants_":[-9213624152780173787,-5982135693274236766,-5396430067534345835,-2363572399258163690,-2255081376624876153,-320252043164433323,1280603170430058832,2648872121679578871,4076507060053755550,6390584767367481427,6475772422542545541,6480002864764397731,6871118355510909196,7049518756068236715,8591929121087659168],"qHole_":5033554600497872881}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q14[1] = conjure_aux3 | q14 <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q14[1] = conjure_aux3 | q14 <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: or([q14[1] = conjure_aux3 | q14 <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: matrix-comprehension-literal: Vertical rule for matrix-comprehension on matrix literal
                                   flatten(1, [[q14[1] = conjure_aux3 | letting q14 be (3, 4)], [q14[1] = conjure_aux3 | letting q14 be (4, 3)]; int(1..2)])
storedChoice:
[q14[1] = conjure_aux3 | q14 <- [(3, 4), (4, 3); int(1..2)]] 8665374887955696009
AnsweredRule {qHole_ = 8665374887955696009, qAscendants_ = fromList [-8790838049079552472,-7586671731712078955,-7257845330645731074,-6187411109644722069,-5035649525051787097,-4935714982215491801,-4790057621145645718,-2980197002499358476,-1690854938850194471,-619668906698634467,1003810935162304708,3378856114517929630,5359983985600686059,5489110086534554143,8428096257079881520], aRuleName_ = "matrix-comprehension-literal"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-literal","qAscendants_":[-8790838049079552472,-7586671731712078955,-7257845330645731074,-6187411109644722069,-5035649525051787097,-4935714982215491801,-4790057621145645718,-2980197002499358476,-1690854938850194471,-619668906698634467,1003810935162304708,3378856114517929630,5359983985600686059,5489110086534554143,8428096257079881520],"qHole_":8665374887955696009}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[q14[1] = conjure_aux3 | letting q14 be (3, 4)], [q14[1] = conjure_aux3 | letting q14 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q14[1]
                              Context #1: q14[1] = conjure_aux3
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q14[1] -883253742927518753
AnsweredRule {qHole_ = -883253742927518753, qAscendants_ = fromList [-9176123018977089417,-9101977553270866225,-9093406545418508012,-9026590884990837132,-7266038392684934735,-7030617368587845027,-6315177474832767189,-6185538668149951971,-5045957588695750237,-2422194591007956529,-2140558072442299093,-1323860184563866252,370104820105510026,1657237947942821584,1725179241386393490,3615940558330371386,6441285251735452902,7836445554474639282,8733492850970682893], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-9176123018977089417,-9101977553270866225,-9093406545418508012,-9026590884990837132,-7266038392684934735,-7030617368587845027,-6315177474832767189,-6185538668149951971,-5045957588695750237,-2422194591007956529,-2140558072442299093,-1323860184563866252,370104820105510026,1657237947942821584,1725179241386393490,3615940558330371386,6441285251735452902,7836445554474639282,8733492850970682893],"qHole_":-883253742927518753}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3 | letting q14 be (3, 4)], [q14[1] = conjure_aux3 | letting q14 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q14[1]
                              Context #1: q14[1] = conjure_aux3
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q14[1] -883253742927518753
AnsweredRule {qHole_ = -883253742927518753, qAscendants_ = fromList [-8969758503132111487,-6784916903301812310,-4362502606594339694,-2424885897194395863,-2417099766119933872,-661357570700780995,659540462714969701,741299023684531871,841316382876489834,1080971480076294633,2455636718555289611,4781036327687591913,6314971418857005121,6957705147325524125,7520484523970872436,7814781884486080266,8472710336593287104,8733492850970682893,9124601515932951508], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8969758503132111487,-6784916903301812310,-4362502606594339694,-2424885897194395863,-2417099766119933872,-661357570700780995,659540462714969701,741299023684531871,841316382876489834,1080971480076294633,2455636718555289611,4781036327687591913,6314971418857005121,6957705147325524125,7520484523970872436,7814781884486080266,8472710336593287104,8733492850970682893,9124601515932951508],"qHole_":-883253742927518753}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3 | letting q14 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = conjure_aux3 | letting q14 be (4, 3)]
                              Context #1: [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3 | letting q14 be (4, 3)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [4 = conjure_aux3 |]
storedChoice:
[4 = conjure_aux3 | letting q14 be (4, 3)] 5094133043100232579
AnsweredRule {qHole_ = 5094133043100232579, qAscendants_ = fromList [-8909122354700020440,-7460733051808423716,-5113575940370069634,-3275789614875181527,-1485928817419295239,-1453326525258547920,-1190111094765899527,-425934852058965166,-227269000323710205,1017324948146570036,2402920626236815200,4379418785875775437,5239709721973149055,5447511985754467121,6138327529543829831,6983653976480365703,7190718169255452642], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8909122354700020440,-7460733051808423716,-5113575940370069634,-3275789614875181527,-1485928817419295239,-1453326525258547920,-1190111094765899527,-425934852058965166,-227269000323710205,1017324948146570036,2402920626236815200,4379418785875775437,5239709721973149055,5447511985754467121,6138327529543829831,6983653976480365703,7190718169255452642],"qHole_":5094133043100232579}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3 |]; int(1..2)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = conjure_aux3 |]
                              Context #1: [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3 |]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [4 = conjure_aux3; int(1)]
storedChoice:
[4 = conjure_aux3 |] 6112956542716486877
AnsweredRule {qHole_ = 6112956542716486877, qAscendants_ = fromList [-9207305118438100391,-6369735332026353512,-5991924291783106431,-5776209435213632803,-3830978856990678993,-3641847297966420112,-338462998493300906,2767710529868660813,4005580531872772405,4397758740249101114,4804584669642102451,5890086814982925863,6459294084780550343,6686373777934096773,7031238571308724387,7962655793307038867,8888369891598567800], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-9207305118438100391,-6369735332026353512,-5991924291783106431,-5776209435213632803,-3830978856990678993,-3641847297966420112,-338462998493300906,2767710529868660813,4005580531872772405,4397758740249101114,4804584669642102451,5890086814982925863,6459294084780550343,6686373777934096773,7031238571308724387,7962655793307038867,8888369891598567800],"qHole_":6112956542716486877}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3; int(1)]; int(1..2)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = conjure_aux3 | letting q14 be (3, 4)]
                              Context #1: [[3 = conjure_aux3 | letting q14 be (3, 4)], [4 = conjure_aux3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [3 = conjure_aux3 |]
storedChoice:
[3 = conjure_aux3 | letting q14 be (3, 4)] 4832497823804752928
AnsweredRule {qHole_ = 4832497823804752928, qAscendants_ = fromList [-6677145406315480965,-5384732204964843677,-3071059650417301550,-2603160466482895011,-2221619722341004417,-1557091775694725768,-1403621344696630627,711266062685662619,1333581340284470498,1611305677733360901,2753561903646462793,3866947117330481491,5332477917871449756,5559142600358984796,6001232326845461178,7602738452352881434,8088691831228319750], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-6677145406315480965,-5384732204964843677,-3071059650417301550,-2603160466482895011,-2221619722341004417,-1557091775694725768,-1403621344696630627,711266062685662619,1333581340284470498,1611305677733360901,2753561903646462793,3866947117330481491,5332477917871449756,5559142600358984796,6001232326845461178,7602738452352881434,8088691831228319750],"qHole_":4832497823804752928}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3 |], [4 = conjure_aux3; int(1)]; int(1..2)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = conjure_aux3 |]
                              Context #1: [[3 = conjure_aux3 |], [4 = conjure_aux3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [3 = conjure_aux3; int(1)]
storedChoice:
[3 = conjure_aux3 |] -185461686146028532
AnsweredRule {qHole_ = -185461686146028532, qAscendants_ = fromList [-8289289739114023416,-8221845150149788696,-8019537499083765163,-7053954318911112143,-6092536859292112896,-4070943207855695476,-4028159753280221929,-3732495125634815821,-3238009362727088795,-282387919327309193,1775857482582255809,1882693949567706262,2362052944268224547,4832344585872237142,7445111209011732230,7705507659096261482,8654062028269091919], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8289289739114023416,-8221845150149788696,-8019537499083765163,-7053954318911112143,-6092536859292112896,-4070943207855695476,-4028159753280221929,-3732495125634815821,-3238009362727088795,-282387919327309193,1775857482582255809,1882693949567706262,2362052944268224547,4832344585872237142,7445111209011732230,7705507659096261482,8654062028269091919],"qHole_":-185461686146028532}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux3; int(1)], [4 = conjure_aux3; int(1)]; int(1..2)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or(flatten(1, [[3 = conjure_aux3; int(1)], [4 = conjure_aux3; int(1)]; int(1..2)]))
                              Context #1: !or(flatten(1, [[3 = conjure_aux3; int(1)], [4 = conjure_aux3; int(1)]; int(1..2)]))
Picking the only option: Answer 1: quantifier-shift3: Shifting quantifier inwards
                                   or([3 = conjure_aux3; int(1)]) \/ or([4 = conjure_aux3; int(1)])
storedChoice:
or(flatten(1, [[3 = conjure_aux3; int(1)], [4 = conjure_aux3; int(1)]; int(1..2)])) 6206761561595236625
AnsweredRule {qHole_ = 6206761561595236625, qAscendants_ = fromList [-9091665958233421775,-8534800408556100581,-8389275971974927944,-7928483109077342673,-7581357772290646644,-7037234840397785533,-6263532840176792370,-5427006571018076668,-4431680199820092864,-4076541738995400933,-1064366526874994538,5387747797148225385,6292098423078440671,8420337927154511626], aRuleName_ = "quantifier-shift3"}
LF:  {"AnsweredRule":{"aRuleName_":"quantifier-shift3","qAscendants_":[-9091665958233421775,-8534800408556100581,-8389275971974927944,-7928483109077342673,-7581357772290646644,-7037234840397785533,-6263532840176792370,-5427006571018076668,-4431680199820092864,-4076541738995400933,-1064366526874994538,5387747797148225385,6292098423078440671,8420337927154511626],"qHole_":6206761561595236625}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!(or([3 = conjure_aux3; int(1)]) \/ or([4 = conjure_aux3; int(1)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or([3 = conjure_aux3; int(1)])
                              Context #1: [or([3 = conjure_aux3; int(1)]), or([4 = conjure_aux3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   3 = conjure_aux3
storedChoice:
or([3 = conjure_aux3; int(1)]) -3434962391173132894
AnsweredRule {qHole_ = -3434962391173132894, qAscendants_ = fromList [-7235853985473547952,-6866498255018164123,-4960622746477117042,-4585543795134183636,-4105761649660625353,-3524766623875920799,-2347278582408429201,-1565913897093032045,-636316196669785718,259925545372009536,2634241883209911323,4718505660743647939,6517008955702082360,6653106233829268540,7728404530962223160,8536818627412251687], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7235853985473547952,-6866498255018164123,-4960622746477117042,-4585543795134183636,-4105761649660625353,-3524766623875920799,-2347278582408429201,-1565913897093032045,-636316196669785718,259925545372009536,2634241883209911323,4718505660743647939,6517008955702082360,6653106233829268540,7728404530962223160,8536818627412251687],"qHole_":-3434962391173132894}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!(3 = conjure_aux3 \/ or([4 = conjure_aux3; int(1)])) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or([4 = conjure_aux3; int(1)])
                              Context #1: [3 = conjure_aux3, or([4 = conjure_aux3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   4 = conjure_aux3
storedChoice:
or([4 = conjure_aux3; int(1)]) 8578967638246734293
AnsweredRule {qHole_ = 8578967638246734293, qAscendants_ = fromList [-7767892036023956761,-6284781492183215029,-1727905482554729427,-1356654288157906426,2281150997448020466,2372014189263015226,2446665452257606178,2838934993441470606,4742034938664987168,4756703484454204779,6116173103300050025,6542907600674666418,7911556895678534380,8081136239962017343,8569698893899834293,8949973037119072966], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7767892036023956761,-6284781492183215029,-1727905482554729427,-1356654288157906426,2281150997448020466,2372014189263015226,2446665452257606178,2838934993441470606,4742034938664987168,4756703484454204779,6116173103300050025,6542907600674666418,7911556895678534380,8081136239962017343,8569698893899834293,8949973037119072966],"qHole_":8578967638246734293}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and(flatten(1,
                                                  [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)]))
                              Context #1: [and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])),
                                           !(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1;
                                               int(1..2)]
Picking the only option: Answer 1: quantifier-shift3: Shifting quantifier inwards
                                   and([3 = q8_1 <-> conjure_aux3 = 4; int(1)]) /\ and([4 = q8_1 <-> conjure_aux3 = 3; int(1)])
storedChoice:
and(flatten(1, [[3 = q8_1 <-> conjure_aux3 = 4; int(1)], [4 = q8_1 <-> conjure_aux3 = 3; int(1)]; int(1..2)])) -2199657802844878530
AnsweredRule {qHole_ = -2199657802844878530, qAscendants_ = fromList [-8444650881280502798,-8271565969096831831,-6564446395948378541,-3553121516791984732,-3091505528568185300,-28537057046234944,2611036720111951620,3048392108732098635,4941408088135413888,6187348870363663871,6391218772456415880,9128754183040712545], aRuleName_ = "quantifier-shift3"}
LF:  {"AnsweredRule":{"aRuleName_":"quantifier-shift3","qAscendants_":[-8444650881280502798,-8271565969096831831,-6564446395948378541,-3553121516791984732,-3091505528568185300,-28537057046234944,2611036720111951620,3048392108732098635,4941408088135413888,6187348870363663871,6391218772456415880,9128754183040712545],"qHole_":-2199657802844878530}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   and([3 = q8_1 <-> conjure_aux3 = 4; int(1)]) /\ and([4 = q8_1 <-> conjure_aux3 = 3; int(1)]) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and([3 = q8_1 <-> conjure_aux3 = 4; int(1)])
                              Context #1: [and([3 = q8_1 <-> conjure_aux3 = 4; int(1)]), and([4 = q8_1 <-> conjure_aux3 = 3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   3 = q8_1 <-> conjure_aux3 = 4
storedChoice:
and([3 = q8_1 <-> conjure_aux3 = 4; int(1)]) -82084885825755383
AnsweredRule {qHole_ = -82084885825755383, qAscendants_ = fromList [-7910416632419113217,-6789993106391976797,-6474394686920849630,-4532119084740741428,-4148488185654761721,-3872345874892611968,-3008944008775182264,-2299093800387471961,-1551233151285274759,-649051754905350518,1456233810038530873,2986022555450137983,3688733153117744851,8953876927154124061], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7910416632419113217,-6789993106391976797,-6474394686920849630,-4532119084740741428,-4148488185654761721,-3872345874892611968,-3008944008775182264,-2299093800387471961,-1551233151285274759,-649051754905350518,1456233810038530873,2986022555450137983,3688733153117744851,8953876927154124061],"qHole_":-82084885825755383}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ and([4 = q8_1 <-> conjure_aux3 = 3; int(1)]) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and([4 = q8_1 <-> conjure_aux3 = 3; int(1)])
                              Context #1: [3 = q8_1 <-> conjure_aux3 = 4, and([4 = q8_1 <-> conjure_aux3 = 3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   4 = q8_1 <-> conjure_aux3 = 3
storedChoice:
and([4 = q8_1 <-> conjure_aux3 = 3; int(1)]) 4451202942487357861
AnsweredRule {qHole_ = 4451202942487357861, qAscendants_ = fromList [-7368630815449645005,-4752206960723048197,-2804301512506126649,-1530922004872999299,-236411210949206668,204928372325319241,2335949798361580872,2698852189043337488,3049593885211881070,3728149952134739241,4353487588625663382,5225198894548896615,5925873450508265460,6881890190583065447], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7368630815449645005,-4752206960723048197,-2804301512506126649,-1530922004872999299,-236411210949206668,204928372325319241,2335949798361580872,2698852189043337488,3049593885211881070,3728149952134739241,4353487588625663382,5225198894548896615,5925873450508265460,6881890190583065447],"qHole_":4451202942487357861}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { conjure_aux3
                                      @ find conjure_aux3: int(1..5)
                                        such that
                                            (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                            (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                      }
                              Context #1: conjure_aux2_1 =
                                          { conjure_aux3
                                          @ find conjure_aux3: int(1..5)
                                            such that
                                                (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                          }
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux3
                                   { conjure_aux3
                                   @ find conjure_aux3: int(1..5)
                                     such that
                                         (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                         (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                   }
storedChoice:
{ conjure_aux3
@ find conjure_aux3: int(1..5)
  such that
      (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
      (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
} -3398171252428132748
AnsweredRule {qHole_ = -3398171252428132748, qAscendants_ = fromList [-4801520196462386255,-3106386946478834998,-1836288510476607810,-1423400445383478062,1875892051782461076,3043802995379454474,7974629594191079167,8285823029631020243,8636179585519730549], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-4801520196462386255,-3106386946478834998,-1836288510476607810,-1423400445383478062,1875892051782461076,3043802995379454474,7974629594191079167,8285823029631020243,8636179585519730549],"qHole_":-3398171252428132748}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             conjure_aux2_1 =
                             { conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: conjure_aux2_1 =
                                      { conjure_aux3
                                      @ find conjure_aux3: int(1..5)
                                        such that
                                            (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                            (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                      }
                              Context #1: { conjure_aux2
                                          @ find conjure_aux2_1: int(1..5)
                                            find conjure_aux2_2: int(1..5)
                                            such that
                                                conjure_aux2_1 =
                                                { conjure_aux3
                                                @ find conjure_aux3: int(1..5)
                                                  such that
                                                      (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                      (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                }
                                            such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { conjure_aux2_1 = conjure_aux3
                                   @ find conjure_aux3: int(1..5)
                                     such that
                                         (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                         (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                   }
storedChoice:
conjure_aux2_1 =
{ conjure_aux3
@ find conjure_aux3: int(1..5)
  such that
      (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
      (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
} 7974629594191079167
AnsweredRule {qHole_ = 7974629594191079167, qAscendants_ = fromList [-4801520196462386255,-3106386946478834998,-1836288510476607810,-1423400445383478062,1875892051782461076,3043802995379454474,8285823029631020243,8636179585519730549], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-4801520196462386255,-3106386946478834998,-1836288510476607810,-1423400445383478062,1875892051782461076,3043802995379454474,8285823029631020243,8636179585519730549],"qHole_":7974629594191079167}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: conjure_aux2[2]
                              Context #1: conjure_aux2[2] = image(permutation((3, 4)), (q8[1], q8[2])[2])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: conjure_aux2[2]
                                   conjure_aux2_2
storedChoice:
conjure_aux2[2] 2042003740924818024
AnsweredRule {qHole_ = 2042003740924818024, qAscendants_ = fromList [-7047224780753215240,-3882919266147774615,-2299063140006189613,681365846263239803,6336625794965795994,6485140089845002516,7009155380893464902,7082442116022567493,8239398540167710302], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-7047224780753215240,-3882919266147774615,-2299063140006189613,681365846263239803,6336625794965795994,6485140089845002516,7009155380893464902,7082442116022567493,8239398540167710302],"qHole_":2042003740924818024}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2_2 = image(permutation((3, 4)), (q8[1], q8[2])[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: (q8[1], q8[2])[2]
                              Context #1: image(permutation((3, 4)), (q8[1], q8[2])[2])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: (q8[1], q8[2])[2]
                                   q8[2]
storedChoice:
(q8[1], q8[2])[2] -5502204419920622825
AnsweredRule {qHole_ = -5502204419920622825, qAscendants_ = fromList [-8588231375425367299,-8510895911811768656,-8426633625849827304,-8207238726412672978,-5936144574452389035,-2652871536273271001,-1630485539153521150,-1126023409437003920,6016260006111454055,8400731779430988570], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8588231375425367299,-8510895911811768656,-8426633625849827304,-8207238726412672978,-5936144574452389035,-2652871536273271001,-1630485539153521150,-1126023409437003920,6016260006111454055,8400731779430988570],"qHole_":-5502204419920622825}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2_2 = image(permutation((3, 4)), q8[2])
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q8[2]
                              Context #1: image(permutation((3, 4)), q8[2])
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q8[2]
                                   q8_2
storedChoice:
q8[2] 6051020602090044114
AnsweredRule {qHole_ = 6051020602090044114, qAscendants_ = fromList [-8305205627063512429,-4351892905554585329,-3978385945799741575,-2899802451648727176,-2610387685810348227,-2009358436958284574,-1222951737421888386,-579623331933497389,4724832166697728323,7712861814088489767], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8305205627063512429,-4351892905554585329,-3978385945799741575,-2899802451648727176,-2610387685810348227,-2009358436958284574,-1222951737421888386,-579623331933497389,4724832166697728323,7712861814088489767],"qHole_":6051020602090044114}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that conjure_aux2_2 = image(permutation((3, 4)), q8_2)
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: image(permutation((3, 4)), q8_2)
                              Context #1: conjure_aux2_2 = image(permutation((3, 4)), q8_2)
Picking the only option: Answer 1: permutation-image-literal{AsFunction}: Horizontal rule for permutation literal application to a single value (image), AsFunction representation
                                   { conjure_aux4
                                   @ find conjure_aux4: int(1..5)
                                     such that
                                         and([q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                         (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                                   }
storedChoice:
image(permutation((3, 4)), q8_2) -6566221682376100457
AnsweredRule {qHole_ = -6566221682376100457, qAscendants_ = fromList [-7375621483096556180,-6476209656930651827,-6169031786475517693,-4051333596644929202,-1139526513744825718,614654197146956279,4282607200389588721,4519547606898719585,5902970686666028765], aRuleName_ = "permutation-image-literal{AsFunction}"}
LF:  {"AnsweredRule":{"aRuleName_":"permutation-image-literal{AsFunction}","qAscendants_":[-7375621483096556180,-6476209656930651827,-6169031786475517693,-4051333596644929202,-1139526513744825718,614654197146956279,4282607200389588721,4519547606898719585,5902970686666028765],"qHole_":-6566221682376100457}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and([q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [(3, 4), (4, 3); int(1..2)]
                              Context #1: [q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   [(3, 4), (4, 3); int(1..2)]
storedChoice:
[(3, 4), (4, 3); int(1..2)] 6597397470067790033
AnsweredRule {qHole_ = 6597397470067790033, qAscendants_ = fromList [-8545307407731927617,-8177498968743831179,-5742947888929994190,-4442383996991551152,396642913451874760,889145374549031649,902104300452840084,1328695702543446488,2152276483370682723,4084473456285295179,4905601367831877360,6850337191508996871,7001603146156804613,8689879020318308638], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8545307407731927617,-8177498968743831179,-5742947888929994190,-4442383996991551152,396642913451874760,889145374549031649,902104300452840084,1328695702543446488,2152276483370682723,4084473456285295179,4905601367831877360,6850337191508996871,7001603146156804613,8689879020318308638],"qHole_":6597397470067790033}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and([q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: and([q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: complex-pattern: complex pattern on tuple patterns
                                   [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | q19 <- [(3, 4), (4, 3); int(1..2)]]
storedChoice:
[q15 = q8_2 <-> conjure_aux4 = q16 | (q15, q16) <- [(3, 4), (4, 3); int(1..2)]] 1328695702543446488
AnsweredRule {qHole_ = 1328695702543446488, qAscendants_ = fromList [-8545307407731927617,-8177498968743831179,-5742947888929994190,-4442383996991551152,396642913451874760,889145374549031649,902104300452840084,2152276483370682723,4084473456285295179,4905601367831877360,6850337191508996871,7001603146156804613,8689879020318308638], aRuleName_ = "complex-pattern"}
LF:  {"AnsweredRule":{"aRuleName_":"complex-pattern","qAscendants_":[-8545307407731927617,-8177498968743831179,-5742947888929994190,-4442383996991551152,396642913451874760,889145374549031649,902104300452840084,2152276483370682723,4084473456285295179,4905601367831877360,6850337191508996871,7001603146156804613,8689879020318308638],"qHole_":1328695702543446488}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and([q19[1] = q8_2 <-> conjure_aux4 = q19[2] | q19 <- [(3, 4), (4, 3); int(1..2)]]) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | q19 <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: and([q19[1] = q8_2 <-> conjure_aux4 = q19[2] | q19 <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: matrix-comprehension-literal: Vertical rule for matrix-comprehension on matrix literal
                                   flatten(1,
                                           [[q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (3, 4)],
                                            [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (4, 3)];
                                                int(1..2)])
storedChoice:
[q19[1] = q8_2 <-> conjure_aux4 = q19[2] | q19 <- [(3, 4), (4, 3); int(1..2)]] 2193708270475412974
AnsweredRule {qHole_ = 2193708270475412974, qAscendants_ = fromList [-6135273235547916413,-3511824826747542530,-2817684250930868121,-1400917739936160745,-1319813811263441476,-481597523330641054,222999019742587203,2503474596382683671,4309903314606971320,7082348445248550107,7474061097534958542,8348619552204205832,9141480563237676781], aRuleName_ = "matrix-comprehension-literal"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-literal","qAscendants_":[-6135273235547916413,-3511824826747542530,-2817684250930868121,-1400917739936160745,-1319813811263441476,-481597523330641054,222999019742587203,2503474596382683671,4309903314606971320,7082348445248550107,7474061097534958542,8348619552204205832,9141480563237676781],"qHole_":2193708270475412974}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (3, 4)],
                                                [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q19[1]
                              Context #1: q19[1] = q8_2
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q19[1] 6191924817638487798
AnsweredRule {qHole_ = 6191924817638487798, qAscendants_ = fromList [-7807298629892727492,-7342314879418443169,-6863795700888677384,-4312957023244042045,-4187455163410375661,-3675178923764728484,-2875109432163106677,-562821977670977521,-430646313158070946,645934730965016486,1213611367040462212,1245826829098445208,2464444564009404876,4591515159436918289,5954646064348546905,6209885551316441807,7780749284175319389,8140212805021622098], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-7807298629892727492,-7342314879418443169,-6863795700888677384,-4312957023244042045,-4187455163410375661,-3675178923764728484,-2875109432163106677,-562821977670977521,-430646313158070946,645934730965016486,1213611367040462212,1245826829098445208,2464444564009404876,4591515159436918289,5954646064348546905,6209885551316441807,7780749284175319389,8140212805021622098],"qHole_":6191924817638487798}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (3, 4)], [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q19[2]
                              Context #1: conjure_aux4 = q19[2]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q19[2] 6191080349758138413
AnsweredRule {qHole_ = 6191080349758138413, qAscendants_ = fromList [-6520176996801677506,-5843168008449148354,-5683324553460351353,-4951129330098074556,-4643211621054911287,-3822866046842193137,-3751755282991126720,-2857878400374217220,-1860910263859276895,-1737565941370477352,1050126061434755877,2341740140041990923,2502411580506467583,2525054445025194025,3419152102230274364,7279809536600806905,8523948582780839689,8905640568803089599], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-6520176996801677506,-5843168008449148354,-5683324553460351353,-4951129330098074556,-4643211621054911287,-3822866046842193137,-3751755282991126720,-2857878400374217220,-1860910263859276895,-1737565941370477352,1050126061434755877,2341740140041990923,2502411580506467583,2525054445025194025,3419152102230274364,7279809536600806905,8523948582780839689,8905640568803089599],"qHole_":6191080349758138413}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [q19[1] = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (4, 3)];
                                                    int(1..2)]))
                                   /\ (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q19[1]
                              Context #1: q19[1] = q8_2
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q19[1] 6191924817638487798
AnsweredRule {qHole_ = 6191924817638487798, qAscendants_ = fromList [-8623968074095065085,-7329444732361257248,-4918646323490343107,-3863503547689138135,-3675178923764728484,-3569961048242171061,-3144694525976125140,-3142709837274542140,-3025737286103464396,-2863059074413010081,-2845931958765307537,-1992102340549551315,-1320176390405360702,-727033692116714751,-430646313158070946,4099404035470031281,7496678802752551639,8353918602880186919], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8623968074095065085,-7329444732361257248,-4918646323490343107,-3863503547689138135,-3675178923764728484,-3569961048242171061,-3144694525976125140,-3142709837274542140,-3025737286103464396,-2863059074413010081,-2845931958765307537,-1992102340549551315,-1320176390405360702,-727033692116714751,-430646313158070946,4099404035470031281,7496678802752551639,8353918602880186919],"qHole_":6191924817638487798}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = q19[2] | letting q19 be (4, 3)]; int(1..2)]))
                                   /\ (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q19[2]
                              Context #1: conjure_aux4 = q19[2]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q19[2] 6191080349758138413
AnsweredRule {qHole_ = 6191080349758138413, qAscendants_ = fromList [-8757640153264855213,-8246403386320852045,-7634455432471374117,-6807206396586148212,-6520176996801677506,-3765915116603809328,-3206961831370542574,-2880744773295792633,10288890695967554,1236510066935204208,2127338015569558053,2891526256517846499,4193370254288787506,4672949733519819188,4775978928665173836,5268252065626460890,7614915012244226995,8901849277253604507], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8757640153264855213,-8246403386320852045,-7634455432471374117,-6807206396586148212,-6520176996801677506,-3765915116603809328,-3206961831370542574,-2880744773295792633,10288890695967554,1236510066935204208,2127338015569558053,2891526256517846499,4193370254288787506,4672949733519819188,4775978928665173836,5268252065626460890,7614915012244226995,8901849277253604507],"qHole_":6191080349758138413}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1,
                                               [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3 | letting q19 be (4, 3)]; int(1..2)]))
                                   /\ (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = q8_2 <-> conjure_aux4 = 3 | letting q19 be (4, 3)]
                              Context #1: [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3 | letting q19 be (4, 3)];
                                               int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [4 = q8_2 <-> conjure_aux4 = 3 |]
storedChoice:
[4 = q8_2 <-> conjure_aux4 = 3 | letting q19 be (4, 3)] 1588099557195084353
AnsweredRule {qHole_ = 1588099557195084353, qAscendants_ = fromList [-8793688442874950149,-7572881584565844112,-7548342805617471592,-4348732945489509501,-2395694351007614565,88957386040583823,374422725277413608,1323284114810179273,2396707417125615551,2821870942280363336,4471571311804301542,5264705085330663748,5735937483858420141,6159114761266478893,6376856799016601882], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8793688442874950149,-7572881584565844112,-7548342805617471592,-4348732945489509501,-2395694351007614565,88957386040583823,374422725277413608,1323284114810179273,2396707417125615551,2821870942280363336,4471571311804301542,5264705085330663748,5735937483858420141,6159114761266478893,6376856799016601882],"qHole_":1588099557195084353}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3 |]; int(1..2)])) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = q8_2 <-> conjure_aux4 = 3 |]
                              Context #1: [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3 |]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [4 = q8_2 <-> conjure_aux4 = 3; int(1)]
storedChoice:
[4 = q8_2 <-> conjure_aux4 = 3 |] 5497036040823098170
AnsweredRule {qHole_ = 5497036040823098170, qAscendants_ = fromList [-8392241438280449004,-7601484554155610431,-6546222595955103458,-5296722524234462815,-2359991535599832467,-1063257280645700723,-17895501989558244,635280768506310618,1960340259087120798,3697301678543081257,4285418689022343979,6976383550303671088,8132222765465596941,8451535935592013102,8523836484272235728], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8392241438280449004,-7601484554155610431,-6546222595955103458,-5296722524234462815,-2359991535599832467,-1063257280645700723,-17895501989558244,635280768506310618,1960340259087120798,3697301678543081257,4285418689022343979,6976383550303671088,8132222765465596941,8451535935592013102,8523836484272235728],"qHole_":5497036040823098170}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)]
                              Context #1: [[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [3 = q8_2 <-> conjure_aux4 = 4 |]
storedChoice:
[3 = q8_2 <-> conjure_aux4 = 4 | letting q19 be (3, 4)] 4563840366785778455
AnsweredRule {qHole_ = 4563840366785778455, qAscendants_ = fromList [-8318635854976707433,-5946611935025738568,-5571483100812435886,-5359593091160120138,-5038848917712120091,-4505559122101590956,-4490512703364564363,-3882495187869643600,1795022445773124374,2052386823818313881,3017254667178360325,5004474385002050470,5786646087302900637,8288841898596402765,8964004080555796084], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8318635854976707433,-5946611935025738568,-5571483100812435886,-5359593091160120138,-5038848917712120091,-4505559122101590956,-4490512703364564363,-3882495187869643600,1795022445773124374,2052386823818313881,3017254667178360325,5004474385002050470,5786646087302900637,8288841898596402765,8964004080555796084],"qHole_":4563840366785778455}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4 |], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = q8_2 <-> conjure_aux4 = 4 |]
                              Context #1: [[3 = q8_2 <-> conjure_aux4 = 4 |], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [3 = q8_2 <-> conjure_aux4 = 4; int(1)]
storedChoice:
[3 = q8_2 <-> conjure_aux4 = 4 |] -4963556797043179790
AnsweredRule {qHole_ = -4963556797043179790, qAscendants_ = fromList [-8774772560597070458,-8569754725622420077,-7014391000977899535,-5142692957413181259,-4041649316716467790,-3712748679124722967,-622761194274709583,-434728569439334546,1040357877965562186,2786263529603136423,3452832737484532816,4830299290996501437,5939727597018131278,7229121740432553148,8127256833064397799], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8774772560597070458,-8569754725622420077,-7014391000977899535,-5142692957413181259,-4041649316716467790,-3712748679124722967,-622761194274709583,-434728569439334546,1040357877965562186,2786263529603136423,3452832737484532816,4830299290996501437,5939727597018131278,7229121740432553148,8127256833064397799],"qHole_":-4963556797043179790}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [(3, 4), (4, 3); int(1..2)]
                              Context #1: [q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   [(3, 4), (4, 3); int(1..2)]
storedChoice:
[(3, 4), (4, 3); int(1..2)] 6597397470067790033
AnsweredRule {qHole_ = 6597397470067790033, qAscendants_ = fromList [-8633754808918514186,-8188184727507762196,-5677541651570710819,-4916174755379616322,-4850199604535152020,-3462648503323623219,-2367628624258445968,-2307855029918049024,1883982971068606087,1912870777007720445,2809445194379708718,3667006364909395131,3677477140697149393,7256127331114215867,8364657527657792986,9047491038558976704], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8633754808918514186,-8188184727507762196,-5677541651570710819,-4916174755379616322,-4850199604535152020,-3462648503323623219,-2367628624258445968,-2307855029918049024,1883982971068606087,1912870777007720445,2809445194379708718,3667006364909395131,3677477140697149393,7256127331114215867,8364657527657792986,9047491038558976704],"qHole_":6597397470067790033}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: or([q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: complex-pattern: complex pattern on tuple patterns
                                   [q20[1] = conjure_aux4 | q20 <- [(3, 4), (4, 3); int(1..2)]]
storedChoice:
[q17 = conjure_aux4 | (q17, q18) <- [(3, 4), (4, 3); int(1..2)]] -4850199604535152020
AnsweredRule {qHole_ = -4850199604535152020, qAscendants_ = fromList [-8633754808918514186,-8188184727507762196,-5677541651570710819,-4916174755379616322,-3462648503323623219,-2367628624258445968,-2307855029918049024,1883982971068606087,1912870777007720445,2809445194379708718,3667006364909395131,3677477140697149393,7256127331114215867,8364657527657792986,9047491038558976704], aRuleName_ = "complex-pattern"}
LF:  {"AnsweredRule":{"aRuleName_":"complex-pattern","qAscendants_":[-8633754808918514186,-8188184727507762196,-5677541651570710819,-4916174755379616322,-3462648503323623219,-2367628624258445968,-2307855029918049024,1883982971068606087,1912870777007720445,2809445194379708718,3667006364909395131,3677477140697149393,7256127331114215867,8364657527657792986,9047491038558976704],"qHole_":-4850199604535152020}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or([q20[1] = conjure_aux4 | q20 <- [(3, 4), (4, 3); int(1..2)]]) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q20[1] = conjure_aux4 | q20 <- [(3, 4), (4, 3); int(1..2)]]
                              Context #1: or([q20[1] = conjure_aux4 | q20 <- [(3, 4), (4, 3); int(1..2)]])
Picking the only option: Answer 1: matrix-comprehension-literal: Vertical rule for matrix-comprehension on matrix literal
                                   flatten(1, [[q20[1] = conjure_aux4 | letting q20 be (3, 4)], [q20[1] = conjure_aux4 | letting q20 be (4, 3)]; int(1..2)])
storedChoice:
[q20[1] = conjure_aux4 | q20 <- [(3, 4), (4, 3); int(1..2)]] -7042519532359788232
AnsweredRule {qHole_ = -7042519532359788232, qAscendants_ = fromList [-8908244575740954826,-5683928670681234592,-5283973279755061591,-3518626964796470528,-1965680338567566419,-1619218070244699183,-1290540526775639182,-1001280480543716507,-920250991117702438,-37243485035014411,3109960451075183399,3577717700431629359,4854879008546753238,5736831950861882173,7673200081862847690], aRuleName_ = "matrix-comprehension-literal"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-literal","qAscendants_":[-8908244575740954826,-5683928670681234592,-5283973279755061591,-3518626964796470528,-1965680338567566419,-1619218070244699183,-1290540526775639182,-1001280480543716507,-920250991117702438,-37243485035014411,3109960451075183399,3577717700431629359,4854879008546753238,5736831950861882173,7673200081862847690],"qHole_":-7042519532359788232}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[q20[1] = conjure_aux4 | letting q20 be (3, 4)], [q20[1] = conjure_aux4 | letting q20 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q20[1]
                              Context #1: q20[1] = conjure_aux4
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   3
storedChoice:
q20[1] -5066820997822192518
AnsweredRule {qHole_ = -5066820997822192518, qAscendants_ = fromList [-8114810939578997179,-5955986499643421728,-5766477344136638660,-3619457499884836706,-3596989804158315723,-3512526206489503481,-2484614995521209041,-1748033148869835596,-58454364784882596,76873978234325305,2489610439802360191,3564003602712422871,3732529855370416098,3884465148016108231,4296494138735898078,4399359040184583027,4639251469994992570,7395797297508748841,7886700597594415296], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8114810939578997179,-5955986499643421728,-5766477344136638660,-3619457499884836706,-3596989804158315723,-3512526206489503481,-2484614995521209041,-1748033148869835596,-58454364784882596,76873978234325305,2489610439802360191,3564003602712422871,3732529855370416098,3884465148016108231,4296494138735898078,4399359040184583027,4639251469994992570,7395797297508748841,7886700597594415296],"qHole_":-5066820997822192518}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4 | letting q20 be (3, 4)], [q20[1] = conjure_aux4 | letting q20 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q20[1]
                              Context #1: q20[1] = conjure_aux4
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   4
storedChoice:
q20[1] -5066820997822192518
AnsweredRule {qHole_ = -5066820997822192518, qAscendants_ = fromList [-8725074021340919078,-8574349549577316045,-7990711773149197775,-7723660686298995374,-6875295913338400819,-5695102429637848602,-5273340809049818279,-3512526206489503481,-2862537938983036678,-2765562469061820724,-807453819412548209,-307031570223611599,37627954002053673,516678838692838411,3479854824023329968,6753745594226090750,8107007183604066764,8502378019651797201,9046378511697116254], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8725074021340919078,-8574349549577316045,-7990711773149197775,-7723660686298995374,-6875295913338400819,-5695102429637848602,-5273340809049818279,-3512526206489503481,-2862537938983036678,-2765562469061820724,-807453819412548209,-307031570223611599,37627954002053673,516678838692838411,3479854824023329968,6753745594226090750,8107007183604066764,8502378019651797201,9046378511697116254],"qHole_":-5066820997822192518}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4 | letting q20 be (4, 3)]; int(1..2)])) <->
                                    conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = conjure_aux4 | letting q20 be (4, 3)]
                              Context #1: [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4 | letting q20 be (4, 3)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [4 = conjure_aux4 |]
storedChoice:
[4 = conjure_aux4 | letting q20 be (4, 3)] -4659269292751863231
AnsweredRule {qHole_ = -4659269292751863231, qAscendants_ = fromList [-8139107762275405780,-6067050360933011415,-4668927100952759839,-2832336555945972970,-2685263499350289956,-712998101401819851,-662867422474666417,-634413128047463436,1314890692039055455,1461492958057141352,1536420920342600247,1612507314243025908,6104410666907258834,6818646762744932078,7002085677101186921,7870098581639353518,8074964079189467219], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8139107762275405780,-6067050360933011415,-4668927100952759839,-2832336555945972970,-2685263499350289956,-712998101401819851,-662867422474666417,-634413128047463436,1314890692039055455,1461492958057141352,1536420920342600247,1612507314243025908,6104410666907258834,6818646762744932078,7002085677101186921,7870098581639353518,8074964079189467219],"qHole_":-4659269292751863231}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4 |]; int(1..2)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [4 = conjure_aux4 |]
                              Context #1: [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4 |]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [4 = conjure_aux4; int(1)]
storedChoice:
[4 = conjure_aux4 |] 3103944569848083730
AnsweredRule {qHole_ = 3103944569848083730, qAscendants_ = fromList [-6499292278244277577,-5447382347614094034,-3901800536920366688,-3381517728243229044,-2903466984087021575,-1629155788585143592,-595707724612505928,-531462185798445081,-436711175201990026,-305874969643107400,713364048257302949,3760728491479375708,4192007196113212495,5520591029544627590,7106210168219555744,7226177407162985748,8785470622724542357], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-6499292278244277577,-5447382347614094034,-3901800536920366688,-3381517728243229044,-2903466984087021575,-1629155788585143592,-595707724612505928,-531462185798445081,-436711175201990026,-305874969643107400,713364048257302949,3760728491479375708,4192007196113212495,5520591029544627590,7106210168219555744,7226177407162985748,8785470622724542357],"qHole_":3103944569848083730}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4; int(1)]; int(1..2)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = conjure_aux4 | letting q20 be (3, 4)]
                              Context #1: [[3 = conjure_aux4 | letting q20 be (3, 4)], [4 = conjure_aux4; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Inlining comprehension lettings.
                                   [3 = conjure_aux4 |]
storedChoice:
[3 = conjure_aux4 | letting q20 be (3, 4)] -6255934535417186594
AnsweredRule {qHole_ = -6255934535417186594, qAscendants_ = fromList [-7136276057455168685,-7072459974569890512,-6196259248273364037,-5834210587143255228,-2665342865711637679,-1906879012656170539,-1522455433242873900,752122676500601510,1351313430292206143,2164743633705935677,2917302706197316348,3522536415221397176,3844998889588585321,5240671478404014136,7264763306810372171,7563078030555210243,8716248641960869542], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-7136276057455168685,-7072459974569890512,-6196259248273364037,-5834210587143255228,-2665342865711637679,-1906879012656170539,-1522455433242873900,752122676500601510,1351313430292206143,2164743633705935677,2917302706197316348,3522536415221397176,3844998889588585321,5240671478404014136,7264763306810372171,7563078030555210243,8716248641960869542],"qHole_":-6255934535417186594}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4 |], [4 = conjure_aux4; int(1)]; int(1..2)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [3 = conjure_aux4 |]
                              Context #1: [[3 = conjure_aux4 |], [4 = conjure_aux4; int(1)]; int(1..2)]
Picking the only option: Answer 1: generators-first: Empty generators.
                                   [3 = conjure_aux4; int(1)]
storedChoice:
[3 = conjure_aux4 |] -2658614992963116405
AnsweredRule {qHole_ = -2658614992963116405, qAscendants_ = fromList [-8200797483737906583,-7142891394430515063,-5048865527690557400,-3204141723258765628,-2755421715163082104,-2150417528239571907,-427238415401958863,345854652969155162,444587743724873706,1433275916120849547,2082716253070264500,3621608353720498501,3817394469011428558,4338626750910725978,6129719379140106144,6899422834286368127,8748622476088678609], aRuleName_ = "generators-first"}
LF:  {"AnsweredRule":{"aRuleName_":"generators-first","qAscendants_":[-8200797483737906583,-7142891394430515063,-5048865527690557400,-3204141723258765628,-2755421715163082104,-2150417528239571907,-427238415401958863,345854652969155162,444587743724873706,1433275916120849547,2082716253070264500,3621608353720498501,3817394469011428558,4338626750910725978,6129719379140106144,6899422834286368127,8748622476088678609],"qHole_":-2658614992963116405}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!or(flatten(1, [[3 = conjure_aux4; int(1)], [4 = conjure_aux4; int(1)]; int(1..2)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or(flatten(1, [[3 = conjure_aux4; int(1)], [4 = conjure_aux4; int(1)]; int(1..2)]))
                              Context #1: !or(flatten(1, [[3 = conjure_aux4; int(1)], [4 = conjure_aux4; int(1)]; int(1..2)]))
Picking the only option: Answer 1: quantifier-shift3: Shifting quantifier inwards
                                   or([3 = conjure_aux4; int(1)]) \/ or([4 = conjure_aux4; int(1)])
storedChoice:
or(flatten(1, [[3 = conjure_aux4; int(1)], [4 = conjure_aux4; int(1)]; int(1..2)])) 1792302133485940861
AnsweredRule {qHole_ = 1792302133485940861, qAscendants_ = fromList [-9215156694345218491,-7884159941367425225,-4061787575651201278,-2348548688413524686,-1616656984063374174,1019247903219888070,1202444192825383566,2448039896892401119,2522006493315280277,2872569756943491545,3292387117872397760,5871641527667180654,6531511286127386564,8891172200144465433], aRuleName_ = "quantifier-shift3"}
LF:  {"AnsweredRule":{"aRuleName_":"quantifier-shift3","qAscendants_":[-9215156694345218491,-7884159941367425225,-4061787575651201278,-2348548688413524686,-1616656984063374174,1019247903219888070,1202444192825383566,2448039896892401119,2522006493315280277,2872569756943491545,3292387117872397760,5871641527667180654,6531511286127386564,8891172200144465433],"qHole_":1792302133485940861}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!(or([3 = conjure_aux4; int(1)]) \/ or([4 = conjure_aux4; int(1)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or([3 = conjure_aux4; int(1)])
                              Context #1: [or([3 = conjure_aux4; int(1)]), or([4 = conjure_aux4; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   3 = conjure_aux4
storedChoice:
or([3 = conjure_aux4; int(1)]) -2238338300082489653
AnsweredRule {qHole_ = -2238338300082489653, qAscendants_ = fromList [-9135090969161870748,-7040580929681195434,-5844866756595959210,-5200489563969105483,-5135428809631204876,-4567662440315024812,-2637178807861984772,-1043830869774709897,117930584853289771,1197239461988022471,4464393825362555947,5063705836807996732,5078493517063792951,6402729242588877157,6830536617247247401,7925032212346973439], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-9135090969161870748,-7040580929681195434,-5844866756595959210,-5200489563969105483,-5135428809631204876,-4567662440315024812,-2637178807861984772,-1043830869774709897,117930584853289771,1197239461988022471,4464393825362555947,5063705836807996732,5078493517063792951,6402729242588877157,6830536617247247401,7925032212346973439],"qHole_":-2238338300082489653}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!(3 = conjure_aux4 \/ or([4 = conjure_aux4; int(1)])) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: or([4 = conjure_aux4; int(1)])
                              Context #1: [3 = conjure_aux4, or([4 = conjure_aux4; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   4 = conjure_aux4
storedChoice:
or([4 = conjure_aux4; int(1)]) 6931996324238769216
AnsweredRule {qHole_ = 6931996324238769216, qAscendants_ = fromList [-8301199506799591941,-7558092101252853604,-6067998700973920226,-5155701249953128914,-4576047313272360415,-4347126985617275804,-2751859814401093547,137469789217709822,144729713112841205,2146657550292868874,3729312864595267230,4118600647582069537,4766806173317946186,4942755527663293565,6086894017411589008,8428538202899570704], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-8301199506799591941,-7558092101252853604,-6067998700973920226,-5155701249953128914,-4576047313272360415,-4347126985617275804,-2751859814401093547,137469789217709822,144729713112841205,2146657550292868874,3729312864595267230,4118600647582069537,4766806173317946186,4942755527663293565,6086894017411589008,8428538202899570704],"qHole_":6931996324238769216}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and(flatten(1,
                                                  [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)]))
                              Context #1: [and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])),
                                           !(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2;
                                               int(1..2)]
Picking the only option: Answer 1: quantifier-shift3: Shifting quantifier inwards
                                   and([3 = q8_2 <-> conjure_aux4 = 4; int(1)]) /\ and([4 = q8_2 <-> conjure_aux4 = 3; int(1)])
storedChoice:
and(flatten(1, [[3 = q8_2 <-> conjure_aux4 = 4; int(1)], [4 = q8_2 <-> conjure_aux4 = 3; int(1)]; int(1..2)])) 6498896587051443094
AnsweredRule {qHole_ = 6498896587051443094, qAscendants_ = fromList [-9122266668816456873,-8763687680398485956,-6768148177044187855,-5775912378426088215,-3542921895788471154,-2263838003336096906,-202295424977994982,851884620329916301,5528267415991175666,6533818616419587005,7566808087161406219,8046934030769361906], aRuleName_ = "quantifier-shift3"}
LF:  {"AnsweredRule":{"aRuleName_":"quantifier-shift3","qAscendants_":[-9122266668816456873,-8763687680398485956,-6768148177044187855,-5775912378426088215,-3542921895788471154,-2263838003336096906,-202295424977994982,851884620329916301,5528267415991175666,6533818616419587005,7566808087161406219,8046934030769361906],"qHole_":6498896587051443094}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   and([3 = q8_2 <-> conjure_aux4 = 4; int(1)]) /\ and([4 = q8_2 <-> conjure_aux4 = 3; int(1)]) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and([3 = q8_2 <-> conjure_aux4 = 4; int(1)])
                              Context #1: [and([3 = q8_2 <-> conjure_aux4 = 4; int(1)]), and([4 = q8_2 <-> conjure_aux4 = 3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   3 = q8_2 <-> conjure_aux4 = 4
storedChoice:
and([3 = q8_2 <-> conjure_aux4 = 4; int(1)]) 4625414366441981983
AnsweredRule {qHole_ = 4625414366441981983, qAscendants_ = fromList [-5032104045245797729,-4260367211447941052,-3800321491279460974,-3527728036515378511,-3186771756499085870,-2663126455000061452,-2397177437658285933,-953818733459672679,51316433765895449,382670796215945555,1275044521375561569,2333080611421701721,2485864324914475150,5509053191108998898], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-5032104045245797729,-4260367211447941052,-3800321491279460974,-3527728036515378511,-3186771756499085870,-2663126455000061452,-2397177437658285933,-953818733459672679,51316433765895449,382670796215945555,1275044521375561569,2333080611421701721,2485864324914475150,5509053191108998898],"qHole_":4625414366441981983}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ and([4 = q8_2 <-> conjure_aux4 = 3; int(1)]) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and([4 = q8_2 <-> conjure_aux4 = 3; int(1)])
                              Context #1: [3 = q8_2 <-> conjure_aux4 = 4, and([4 = q8_2 <-> conjure_aux4 = 3; int(1)]); int(1..2)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   4 = q8_2 <-> conjure_aux4 = 3
storedChoice:
and([4 = q8_2 <-> conjure_aux4 = 3; int(1)]) -8650590815054601249
AnsweredRule {qHole_ = -8650590815054601249, qAscendants_ = fromList [-7526881736718068312,-7405557604309373817,-7201686808491642883,-6330762734028692340,-5804239247306276412,-5043128294307900798,-4578161512601023984,-2463121278901514889,303127519297990446,594877140964359361,1533543948414682137,4243960396898301951,6573830124911821771,7997158881778982126], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7526881736718068312,-7405557604309373817,-7201686808491642883,-6330762734028692340,-5804239247306276412,-5043128294307900798,-4578161512601023984,-2463121278901514889,303127519297990446,594877140964359361,1533543948414682137,4243960396898301951,6573830124911821771,7997158881778982126],"qHole_":-8650590815054601249}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { conjure_aux4
                                      @ find conjure_aux4: int(1..5)
                                        such that
                                            (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                            (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                      }
                              Context #1: conjure_aux2_2 =
                                          { conjure_aux4
                                          @ find conjure_aux4: int(1..5)
                                            such that
                                                (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                          }
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux4
                                   { conjure_aux4
                                   @ find conjure_aux4: int(1..5)
                                     such that
                                         (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                         (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                   }
storedChoice:
{ conjure_aux4
@ find conjure_aux4: int(1..5)
  such that
      (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
      (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
} -5523540219623150802
AnsweredRule {qHole_ = -5523540219623150802, qAscendants_ = fromList [-8941059882607301911,-4338998493244249628,-2962415465773075069,-2259331243426380901,-565469044512126150,-60812526271457966,2469584683440447504,4682955345466050776,5578803032032481190], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-8941059882607301911,-4338998493244249628,-2962415465773075069,-2259331243426380901,-565469044512126150,-60812526271457966,2469584683440447504,4682955345466050776,5578803032032481190],"qHole_":-5523540219623150802}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             conjure_aux2_2 =
                             { conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: conjure_aux2_2 =
                                      { conjure_aux4
                                      @ find conjure_aux4: int(1..5)
                                        such that
                                            (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                            (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                      }
                              Context #1: { conjure_aux2
                                          @ find conjure_aux2_1: int(1..5)
                                            find conjure_aux2_2: int(1..5)
                                            such that
                                                { conjure_aux2_1 = conjure_aux3
                                                @ find conjure_aux3: int(1..5)
                                                  such that
                                                      (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                      (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                }
                                            such that
                                                conjure_aux2_2 =
                                                { conjure_aux4
                                                @ find conjure_aux4: int(1..5)
                                                  such that
                                                      (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                      (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                }
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { conjure_aux2_2 = conjure_aux4
                                   @ find conjure_aux4: int(1..5)
                                     such that
                                         (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                         (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                   }
storedChoice:
conjure_aux2_2 =
{ conjure_aux4
@ find conjure_aux4: int(1..5)
  such that
      (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
      (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
} 4682955345466050776
AnsweredRule {qHole_ = 4682955345466050776, qAscendants_ = fromList [-8941059882607301911,-4338998493244249628,-2962415465773075069,-2259331243426380901,-565469044512126150,-60812526271457966,2469584683440447504,5578803032032481190], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-8941059882607301911,-4338998493244249628,-2962415465773075069,-2259331243426380901,-565469044512126150,-60812526271457966,2469584683440447504,5578803032032481190],"qHole_":4682955345466050776}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             { conjure_aux2_2 = conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }
                       in conjure_aux1
                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { conjure_aux2
                                      @ find conjure_aux2_1: int(1..5)
                                        find conjure_aux2_2: int(1..5)
                                        such that
                                            { conjure_aux2_1 = conjure_aux3
                                            @ find conjure_aux3: int(1..5)
                                              such that
                                                  (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                  (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                            }
                                        such that
                                            { conjure_aux2_2 = conjure_aux4
                                            @ find conjure_aux4: int(1..5)
                                              such that
                                                  (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                  (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                            }
                                      }
                                      in conjure_aux1
                              Context #1: [{ conjure_aux2
                                           @ find conjure_aux2_1: int(1..5)
                                             find conjure_aux2_2: int(1..5)
                                             such that
                                                 { conjure_aux2_1 = conjure_aux3
                                                 @ find conjure_aux3: int(1..5)
                                                   such that
                                                       (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                       (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                 }
                                             such that
                                                 { conjure_aux2_2 = conjure_aux4
                                                 @ find conjure_aux4: int(1..5)
                                                   such that
                                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                 }
                                           }
                                           in conjure_aux1
                                               | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]]
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { conjure_aux2 in conjure_aux1
                                   @ find conjure_aux2_1: int(1..5)
                                     find conjure_aux2_2: int(1..5)
                                     such that
                                         { conjure_aux2_1 = conjure_aux3
                                         @ find conjure_aux3: int(1..5)
                                           such that
                                               (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                               (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                         }
                                     such that
                                         { conjure_aux2_2 = conjure_aux4
                                         @ find conjure_aux4: int(1..5)
                                           such that
                                               (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                               (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                         }
                                   }
storedChoice:
{ conjure_aux2
@ find conjure_aux2_1: int(1..5)
  find conjure_aux2_2: int(1..5)
  such that
      { conjure_aux2_1 = conjure_aux3
      @ find conjure_aux3: int(1..5)
        such that
            (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
            (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
      }
  such that
      { conjure_aux2_2 = conjure_aux4
      @ find conjure_aux4: int(1..5)
        such that
            (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
            (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
      }
}
in conjure_aux1 -8498631454693468162
AnsweredRule {qHole_ = -8498631454693468162, qAscendants_ = fromList [-8906484870153215238,-5210480414835359833,-1572320097158340186,7262859821198064716,7664399396112355801,9199488081424848815], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-8906484870153215238,-5210480414835359833,-1572320097158340186,7262859821198064716,7664399396112355801,9199488081424848815],"qHole_":-8498631454693468162}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2 in conjure_aux1
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             { conjure_aux2_2 = conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8[1], q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q8[1]
                              Context #1: x_RelationAsMatrix[q8[1]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q8[1]
                                   q8_1
storedChoice:
q8[1] 6051865069970393497
AnsweredRule {qHole_ = 6051865069970393497, qAscendants_ = fromList [-8640702807944529160,-7554917160340714381,-7282620252070677492,-4679672213039578282,-3902820972913913543,-1648680758926951321,-323488035431343639,4558015980602682727], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8640702807944529160,-7554917160340714381,-7282620252070677492,-4679672213039578282,-3902820972913913543,-1648680758926951321,-323488035431343639,4558015980602682727],"qHole_":6051865069970393497}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2 in conjure_aux1
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             { conjure_aux2_2 = conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8[2]]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q8[2]
                              Context #1: x_RelationAsMatrix[q8_1, q8[2]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q8[2]
                                   q8_2
storedChoice:
q8[2] 6051020602090044114
AnsweredRule {qHole_ = 6051020602090044114, qAscendants_ = fromList [-1657839898828256711,-1442033437105002979,-382389179101208790,2791764908100697416,2932884812988402663,3044000407645637671,4978224969731597410], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-1657839898828256711,-1442033437105002979,-382389179101208790,2791764908100697416,2932884812988402663,3044000407645637671,4978224969731597410],"qHole_":6051020602090044114}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and([{ conjure_aux2 in conjure_aux1
                       @ find conjure_aux2_1: int(1..5)
                         find conjure_aux2_2: int(1..5)
                         such that
                             { conjure_aux2_1 = conjure_aux3
                             @ find conjure_aux3: int(1..5)
                               such that
                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                             }
                         such that
                             { conjure_aux2_2 = conjure_aux4
                             @ find conjure_aux4: int(1..5)
                               such that
                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                             }
                       }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]])
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [{ conjure_aux2 in conjure_aux1
                                       @ find conjure_aux2_1: int(1..5)
                                         find conjure_aux2_2: int(1..5)
                                         such that
                                             { conjure_aux2_1 = conjure_aux3
                                             @ find conjure_aux3: int(1..5)
                                               such that
                                                   (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                   (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                             }
                                         such that
                                             { conjure_aux2_2 = conjure_aux4
                                             @ find conjure_aux4: int(1..5)
                                               such that
                                                   (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                   (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                             }
                                       }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                              Context #1: and([{ conjure_aux2 in conjure_aux1
                                               @ find conjure_aux2_1: int(1..5)
                                                 find conjure_aux2_2: int(1..5)
                                                 such that
                                                     { conjure_aux2_1 = conjure_aux3
                                                     @ find conjure_aux3: int(1..5)
                                                       such that
                                                           (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                           (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                     }
                                                 such that
                                                     { conjure_aux2_2 = conjure_aux4
                                                     @ find conjure_aux4: int(1..5)
                                                       such that
                                                           (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                           (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                     }
                                               }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]])
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables through a comprehension.
                                   { [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                   @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                              @ find conjure_aux3: int(1..5)
                                                such that
                                                    (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                    (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                              }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                                         and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                              @ find conjure_aux4: int(1..5)
                                                such that
                                                    (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                    (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                              }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
[{ conjure_aux2 in conjure_aux1
 @ find conjure_aux2_1: int(1..5)
   find conjure_aux2_2: int(1..5)
   such that
       { conjure_aux2_1 = conjure_aux3
       @ find conjure_aux3: int(1..5)
         such that
             (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
             (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
       }
   such that
       { conjure_aux2_2 = conjure_aux4
       @ find conjure_aux4: int(1..5)
         such that
             (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
             (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
       }
 }   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]] 4632560015221358179
AnsweredRule {qHole_ = 4632560015221358179, qAscendants_ = fromList [-7796146364068057171,-6981365833241776808,-5029665938164178889,-3928434564447926958,-2893776785872977312], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-7796146364068057171,-6981365833241776808,-5029665938164178889,-3928434564447926958,-2893776785872977312],"qHole_":4632560015221358179}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                 @ find conjure_aux3: int(1..5)
                                   such that
                                       (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                       (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                 @ find conjure_aux4: int(1..5)
                                   such that
                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { [conjure_aux2 in conjure_aux1
                                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                        such that
                                            and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                                 @ find conjure_aux3: int(1..5)
                                                   such that
                                                       (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                       (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                                 @ find conjure_aux4: int(1..5)
                                                   such that
                                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                      }
                              Context #1: and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                              @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                such that
                                                    and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                                         @ find conjure_aux3: int(1..5)
                                                           such that
                                                               (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                               (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                                         }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                                                    and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                                         @ find conjure_aux4: int(1..5)
                                                           such that
                                                               (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                               (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                         }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                              })
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux2_1
                                   { [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                   @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                              @ find conjure_aux3: int(1..5)
                                                such that
                                                    (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                    (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                              }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                                         and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                              @ find conjure_aux4: int(1..5)
                                                such that
                                                    (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                    (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                              }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
{ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
@ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
  find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
  such that
      and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
           @ find conjure_aux3: int(1..5)
             such that
                 (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                 (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
           }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
      and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
           @ find conjure_aux4: int(1..5)
             such that
                 (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                 (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
           }   | q8_1 : int(1..5), q8_2 : int(1..5)])
} 5183357163976320088
AnsweredRule {qHole_ = 5183357163976320088, qAscendants_ = fromList [-5465830923914696498,-4063366109563536561,-2043995450352341839,378335084364868291,1311484366701431644], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-5465830923914696498,-4063366109563536561,-2043995450352341839,378335084364868291,1311484366701431644],"qHole_":5183357163976320088}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                 @ find conjure_aux3: int(1..5)
                                   such that
                                       (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                       (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)]),
                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                 @ find conjure_aux4: int(1..5)
                                   such that
                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                       @ find conjure_aux3: int(1..5)
                                         such that
                                             (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                             (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                       }   | q8_1 : int(1..5), q8_2 : int(1..5)]
                              Context #1: and([{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
                                               @ find conjure_aux3: int(1..5)
                                                 such that
                                                     (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
                                                     (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
                                               }   | q8_1 : int(1..5), q8_2 : int(1..5)])
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables through a comprehension.
                                   { [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                   @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
[{ conjure_aux2_1[q8_1, q8_2] = conjure_aux3
 @ find conjure_aux3: int(1..5)
   such that
       (3 = q8_1 <-> conjure_aux3 = 4) /\ (4 = q8_1 <-> conjure_aux3 = 3) /\
       (!(3 = conjure_aux3 \/ 4 = conjure_aux3) <-> conjure_aux3 = q8_1)
 }   | q8_1 : int(1..5), q8_2 : int(1..5)] -2066028230956466058
AnsweredRule {qHole_ = -2066028230956466058, qAscendants_ = fromList [-8778252753919104373,-5465830923914696498,-4063366109563536561,-2043995450352341839,378335084364868291,1311484366701431644,5183357163976320088], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-8778252753919104373,-5465830923914696498,-4063366109563536561,-2043995450352341839,378335084364868291,1311484366701431644,5183357163976320088],"qHole_":-2066028230956466058}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                  such that
                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                }),
                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                 @ find conjure_aux4: int(1..5)
                                   such that
                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                      @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                        such that
                                            and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                 (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                      }
                              Context #1: and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                              @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                such that
                                                    and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                         (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                                              })
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux3
                                   { [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                   @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
{ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
@ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
  such that
      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
               | q8_1 : int(1..5), q8_2 : int(1..5)])
} -2683400798428888576
AnsweredRule {qHole_ = -2683400798428888576, qAscendants_ = fromList [-7630765854898757381,-5152289056460337438,-4378029185233493510,-2193789157648306228,-780484605375639491,4611290103392876019,8129436120778745950], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-7630765854898757381,-5152289056460337438,-4378029185233493510,-2193789157648306228,-780484605375639491,4611290103392876019,8129436120778745950],"qHole_":-2683400798428888576}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                  such that
                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                }),
                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                 @ find conjure_aux4: int(1..5)
                                   such that
                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2]
                                                 | q8_1 : int(1..5), q8_2 : int(1..5)]
                                          @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                     (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                         | q8_1 : int(1..5), q8_2 : int(1..5)])
                                          })
                              Context #1: { [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                          @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                                    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                      such that
                                                          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                    }),
                                                and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                                     @ find conjure_aux4: int(1..5)
                                                       such that
                                                           (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                           (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                                     }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
and({ [conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      such that
          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                   | q8_1 : int(1..5), q8_2 : int(1..5)])
    }) -7630765854898757381
AnsweredRule {qHole_ = -7630765854898757381, qAscendants_ = fromList [-5152289056460337438,-4378029185233493510,-2193789157648306228,-780484605375639491,4611290103392876019,8129436120778745950], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-5152289056460337438,-4378029185233493510,-2193789157648306228,-780484605375639491,4611290103392876019,8129436120778745950],"qHole_":-7630765854898757381}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                 @ find conjure_aux4: int(1..5)
                                   such that
                                       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                 }   | q8_1 : int(1..5), q8_2 : int(1..5)])
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                       @ find conjure_aux4: int(1..5)
                                         such that
                                             (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                             (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                       }   | q8_1 : int(1..5), q8_2 : int(1..5)]
                              Context #1: and([{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
                                               @ find conjure_aux4: int(1..5)
                                                 such that
                                                     (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
                                                     (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
                                               }   | q8_1 : int(1..5), q8_2 : int(1..5)])
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables through a comprehension.
                                   { [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                   @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
[{ conjure_aux2_2[q8_1, q8_2] = conjure_aux4
 @ find conjure_aux4: int(1..5)
   such that
       (3 = q8_2 <-> conjure_aux4 = 4) /\ (4 = q8_2 <-> conjure_aux4 = 3) /\
       (!(3 = conjure_aux4 \/ 4 = conjure_aux4) <-> conjure_aux4 = q8_2)
 }   | q8_1 : int(1..5), q8_2 : int(1..5)] 4586595665260781575
AnsweredRule {qHole_ = 4586595665260781575, qAscendants_ = fromList [-5189262863924670079,-4576870578376860616,-3657040581488238581,667350004362937900,5588145911994567168,7042957946885141470,7965291691177128164], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-5189262863924670079,-4576870578376860616,-3657040581488238581,667350004362937900,5588145911994567168,7042957946885141470,7965291691177128164],"qHole_":4586595665260781575}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                  such that
                                      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                })
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: { [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                      @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                        such that
                                            and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                 (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                      }
                              Context #1: and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                              @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                such that
                                                    and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                         (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                                              })
Picking the only option: Answer 1: choose-repr-for-locals: Choosing representation for local variable conjure_aux4
                                   { [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                   @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
{ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
@ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
  such that
      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
               | q8_1 : int(1..5), q8_2 : int(1..5)])
} -1434005429531325525
AnsweredRule {qHole_ = -1434005429531325525, qAscendants_ = fromList [-7860778431127922714,-4340120710083553155,-3276746255609047616,-2418004144569851915,-329464522225361142,8566682329173394842,8971959176905079767], aRuleName_ = "choose-repr-for-locals"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-locals","qAscendants_":[-7860778431127922714,-4340120710083553155,-3276746255609047616,-2418004144569851915,-329464522225361142,8566682329173394842,8971959176905079767],"qHole_":-1434005429531325525}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                  such that
                                      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                })
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2]
                                                 | q8_1 : int(1..5), q8_2 : int(1..5)]
                                          @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                     (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                         | q8_1 : int(1..5), q8_2 : int(1..5)])
                                          })
                              Context #1: { [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                          @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                },
                                                and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
                                                    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                      such that
                                                          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                    })
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                              (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   }
storedChoice:
and({ [conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]
    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      such that
          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                   | q8_1 : int(1..5), q8_2 : int(1..5)])
    }) -329464522225361142
AnsweredRule {qHole_ = -329464522225361142, qAscendants_ = fromList [-7860778431127922714,-4340120710083553155,-3276746255609047616,-2418004144569851915,8566682329173394842,8971959176905079767], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-7860778431127922714,-4340120710083553155,-3276746255609047616,-2418004144569851915,8566682329173394842,8971959176905079767],"qHole_":-329464522225361142}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: conjure_aux2 in conjure_aux1
                              Context #1: [conjure_aux2 in conjure_aux1 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
Picking the only option: Answer 1: relation-in: relation membership to existential quantification
                                   or([q27 = conjure_aux2 | q27 <- toSet(conjure_aux1)])
storedChoice:
conjure_aux2 in conjure_aux1 7266634060293924720
AnsweredRule {qHole_ = 7266634060293924720, qAscendants_ = fromList [-7266324578771459181,-6713121642540228318,-5826297241095436731,-5526349309453330732,1756707357159771390,2149626909839152329,4938058042264599181], aRuleName_ = "relation-in"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-in","qAscendants_":[-7266324578771459181,-6713121642540228318,-5826297241095436731,-5526349309453330732,1756707357159771390,2149626909839152329,4938058042264599181],"qHole_":7266634060293924720}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q27 = conjure_aux2 | q27 <- toSet(conjure_aux1)]) | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q27 = conjure_aux2 | q27 <- toSet(conjure_aux1)]
                              Context #1: or([q27 = conjure_aux2 | q27 <- toSet(conjure_aux1)])
Picking the only option: Answer 1: relation-map_in_expr{RelationAsMatrix}: Vertical rule for map_in_expr for relation domains, RelationAsMatrix representation.
                                   [(q28[1], q28[2]) = conjure_aux2 | q28 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]]
storedChoice:
[q27 = conjure_aux2 | q27 <- toSet(conjure_aux1)] -3470261408387399930
AnsweredRule {qHole_ = -3470261408387399930, qAscendants_ = fromList [-8536113027950480792,-7330204231396072871,-4786623393387445427,-4223003553667075844,4116516722814445548,4281838781863596501,6175095517354461663,6559035824535384582], aRuleName_ = "relation-map_in_expr{RelationAsMatrix}"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-map_in_expr{RelationAsMatrix}","qAscendants_":[-8536113027950480792,-7330204231396072871,-4786623393387445427,-4223003553667075844,4116516722814445548,4281838781863596501,6175095517354461663,6559035824535384582],"qHole_":-3470261408387399930}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([(q28[1], q28[2]) = conjure_aux2 | q28 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [(q28[1], q28[2]) = conjure_aux2
                                           | q28 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]]
                              Context #1: or([(q28[1], q28[2]) = conjure_aux2 | q28 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q28 (with type: (int,
                                                                                                                                   int))
                                   [(q28[1], q28[2]) = conjure_aux2 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]]
storedChoice:
[(q28[1], q28[2]) = conjure_aux2 | q28 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]] 4348009411125732066
AnsweredRule {qHole_ = 4348009411125732066, qAscendants_ = fromList [-6592612559904363413,-6472871177545322172,-6453293890463000807,-2235240472846537890,3259852529283772574,4455209103885624492,6352194885377054835,8420829954716127361], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-6592612559904363413,-6472871177545322172,-6453293890463000807,-2235240472846537890,3259852529283772574,4455209103885624492,6352194885377054835,8420829954716127361],"qHole_":4348009411125732066}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([(q28[1], q28[2]) = conjure_aux2 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: (q28[1], q28[2]) = conjure_aux2
                              Context #1: [(q28[1], q28[2]) = conjure_aux2 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]]
Picking the only option: Answer 1: tuple-eq: Horizontal rule for tuple equality
                                   q28[1] = conjure_aux2_1 /\ q28[2] = conjure_aux2_2
storedChoice:
(q28[1], q28[2]) = conjure_aux2 -4124337097652933443
AnsweredRule {qHole_ = -4124337097652933443, qAscendants_ = fromList [-6634517003356473421,-4157154907530130258,-932339049260687039,4056979115757602560,5419805607560390341,5700344114265930133,8275228852675492835,8651388538213571462,8952456806918978808], aRuleName_ = "tuple-eq"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-eq","qAscendants_":[-6634517003356473421,-4157154907530130258,-932339049260687039,4056979115757602560,5419805607560390341,5700344114265930133,8275228852675492835,8651388538213571462,8952456806918978808],"qHole_":-4124337097652933443}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q28[1] = conjure_aux2_1 /\ q28[2] = conjure_aux2_2
                                 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q28[1]
                              Context #1: q28[1] = conjure_aux2_1
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q28[1]
                                   q28_1
storedChoice:
q28[1] 8787010607011614834
AnsweredRule {qHole_ = 8787010607011614834, qAscendants_ = fromList [-8956326597613561383,-6532059540256123763,-6109385609926416455,-3678896154897738560,-419523469793567323,-407169135612228618,2034669589965157861,4997220444967745554,6148375269450574671,6513082934840114429,8747477145020099131,8922317001415918920], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8956326597613561383,-6532059540256123763,-6109385609926416455,-3678896154897738560,-419523469793567323,-407169135612228618,2034669589965157861,4997220444967745554,6148375269450574671,6513082934840114429,8747477145020099131,8922317001415918920],"qHole_":8787010607011614834}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q28_1 = conjure_aux2_1 /\ q28[2] = conjure_aux2_2
                                 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q28[2]
                              Context #1: q28[2] = conjure_aux2_2
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q28[2]
                                   q28_2
storedChoice:
q28[2] 8786166143426335913
AnsweredRule {qHole_ = 8786166143426335913, qAscendants_ = fromList [-7531325615783388500,-6124769537006831453,-2577262930135244673,-590286472771932315,-83534367005148570,715122028962684739,1709615173437954783,5607005680561137835,7486385006046341809,7705725891024727552,8323234866884020390,8780789924434106151], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-7531325615783388500,-6124769537006831453,-2577262930135244673,-590286472771932315,-83534367005148570,715122028962684739,1709615173437954783,5607005680561137835,7486385006046341809,7705725891024727552,8323234866884020390,8780789924434106151],"qHole_":8786166143426335913}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
                                 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28[1], q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q28[1]
                              Context #1: conjure_aux1_RelationAsMatrix[q28[1]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q28[1]
                                   q28_1
storedChoice:
q28[1] 8787010607011614834
AnsweredRule {qHole_ = 8787010607011614834, qAscendants_ = fromList [-6233761776568569553,-6207878452900388515,-3381866216268371578,-560496032557153780,-80631966925160875,1067854355870431415,1108013619790213016,4161317878060049142,4647826867886404607,5228020545282852391,8646369751965333728], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-6233761776568569553,-6207878452900388515,-3381866216268371578,-560496032557153780,-80631966925160875,1067854355870431415,1108013619790213016,4161317878060049142,4647826867886404607,5228020545282852391,8646369751965333728],"qHole_":8787010607011614834}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
                                 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28_1, q28[2]]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q28[2]
                              Context #1: conjure_aux1_RelationAsMatrix[q28_1, q28[2]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q28[2]
                                   q28_2
storedChoice:
q28[2] 8786166143426335913
AnsweredRule {qHole_ = 8786166143426335913, qAscendants_ = fromList [-8932183048783716768,-6021176910053718006,-1484921959836170832,-1243263695470418987,-307241860641088143,5123914162100475129,6415834318102058907,6682610423178443283,7959220516069049554,8895625464985590456], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8932183048783716768,-6021176910053718006,-1484921959836170832,-1243263695470418987,-307241860641088143,5123914162100475129,6415834318102058907,6682610423178443283,7959220516069049554,8895625464985590456],"qHole_":8786166143426335913}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
                                 | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28_1, q28_2]])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
                                           | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28_1, q28_2]]
                              Context #1: or([q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
                                                  | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28_1, q28_2]])
Picking the only option: Answer 1: inline-conditions: Inlining conditions, inside or
                                   [conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                        | q28_1 : int(1..5), q28_2 : int(1..5)]
storedChoice:
[q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2
     | q28_1 : int(1..5), q28_2 : int(1..5), conjure_aux1_RelationAsMatrix[q28_1, q28_2]] -9107354217279316955
AnsweredRule {qHole_ = -9107354217279316955, qAscendants_ = fromList [-7614046741660552896,-7556360939789777851,-6910364700408604777,-6183630476596424374,-2673910102480230275,7059218223957164648,8407785490318688805,8504193122766115214], aRuleName_ = "inline-conditions"}
LF:  {"AnsweredRule":{"aRuleName_":"inline-conditions","qAscendants_":[-7614046741660552896,-7556360939789777851,-6910364700408604777,-6183630476596424374,-2673910102480230275,7059218223957164648,8407785490318688805,8504193122766115214],"qHole_":-9107354217279316955}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  and({ [or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and({ [or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\
                                                 (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                 | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                          @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                },
                                                { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                }
                                          })
                              Context #1: [|x| = |conjure_aux1|,
                                           and({ [or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                          | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                      | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                                               @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                 find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                 such that
                                                     { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                     @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                       such that
                                                           and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                                (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                    | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                     },
                                                     { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                     @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                       such that
                                                           and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                                (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                    | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                     }
                                               });
                                               int(1..2)]
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { and([or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                  | q28_1 : int(1..5), q28_2 : int(1..5)])
                                              | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]])
                                   @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         },
                                         { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         }
                                   }
storedChoice:
and({ [or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
               | q28_1 : int(1..5), q28_2 : int(1..5)])
           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
    @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      such that
          { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
          @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
            such that
                and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                     (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
          },
          { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
          @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
            such that
                and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                     (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
          }
    }) 7825224301270217826
AnsweredRule {qHole_ = 7825224301270217826, qAscendants_ = fromList [-7337214924393354854,-6793331199204698657,4098536301578040545,4694401685199555588], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-7337214924393354854,-6793331199204698657,4098536301578040545,4694401685199555588],"qHole_":7825224301270217826}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  { and([or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\
                                           (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                               | q28_1 : int(1..5), q28_2 : int(1..5)])
                                           | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]]
                              Context #1: and([or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                       | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                   | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]])
Picking the only option: Answer 1: inline-conditions: Inlining conditions, inside and
                                   [x_RelationAsMatrix[q8_1, q8_2] ->
                                    or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                            | q28_1 : int(1..5), q28_2 : int(1..5)])
                                        | q8_1 : int(1..5), q8_2 : int(1..5)]
storedChoice:
[or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
         | q28_1 : int(1..5), q28_2 : int(1..5)])
     | q8_1 : int(1..5), q8_2 : int(1..5), x_RelationAsMatrix[q8_1, q8_2]] -7818394351581759390
AnsweredRule {qHole_ = -7818394351581759390, qAscendants_ = fromList [-8854367752148363141,868987242372315934,1952008385480716564,2094581585082781447,3197112935473569797,5197989222011368608], aRuleName_ = "inline-conditions"}
LF:  {"AnsweredRule":{"aRuleName_":"inline-conditions","qAscendants_":[-8854367752148363141,868987242372315934,1952008385480716564,2094581585082781447,3197112935473569797,5197989222011368608],"qHole_":-7818394351581759390}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  |x| = |conjure_aux1| /\
                  { and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [|x| = |conjure_aux1|,
                                       { and([x_RelationAsMatrix[q8_1, q8_2] ->
                                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                  | q8_1 : int(1..5), q8_2 : int(1..5)])
                                       @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                         find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                         such that
                                             { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                             @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                               such that
                                                   and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                        (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                            | q8_1 : int(1..5), q8_2 : int(1..5)])
                                             },
                                             { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                             @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                               such that
                                                   and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                        (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                            | q8_1 : int(1..5), q8_2 : int(1..5)])
                                             }
                                       };  int(1..2)]
                              Context #1: |x| = |conjure_aux1| /\
                                          { and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                 or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                         | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                          @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                },
                                                { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                }
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { [|x| = |conjure_aux1|,
                                      and([x_RelationAsMatrix[q8_1, q8_2] ->
                                           or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                   | q28_1 : int(1..5), q28_2 : int(1..5)])
                                               | q8_1 : int(1..5), q8_2 : int(1..5)]);
                                          int(1..2)]
                                   @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         },
                                         { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         }
                                   }
storedChoice:
[|x| = |conjure_aux1|,
 { and([x_RelationAsMatrix[q8_1, q8_2] ->
        or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                | q28_1 : int(1..5), q28_2 : int(1..5)])
            | q8_1 : int(1..5), q8_2 : int(1..5)])
 @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
   find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
   such that
       { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
       @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
         such that
             and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                  (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                      | q8_1 : int(1..5), q8_2 : int(1..5)])
       },
       { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
       @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
         such that
             and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                  (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                      | q8_1 : int(1..5), q8_2 : int(1..5)])
       }
 };  int(1..2)] 8700659888572119213
AnsweredRule {qHole_ = 8700659888572119213, qAscendants_ = fromList [1085907639859271742,5213477129051060331,8301951387372896488], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[1085907639859271742,5213477129051060331,8301951387372896488],"qHole_":8700659888572119213}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [|x| = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: |x|
                              Context #1: |x| = |conjure_aux1|
Picking the only option: Answer 1: relation-cardinality: Relation cardinality
                                   |toSet(x)|
storedChoice:
|x| -1852370716973049233
AnsweredRule {qHole_ = -1852370716973049233, qAscendants_ = fromList [-8274899275771564111,-7189265364834618222,-4195293662753593531,-2250203036499850017,4837893138970417558,5156053544824672407], aRuleName_ = "relation-cardinality"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-cardinality","qAscendants_":[-8274899275771564111,-7189265364834618222,-4195293662753593531,-2250203036499850017,4837893138970417558,5156053544824672407],"qHole_":-1852370716973049233}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [|toSet(x)| = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: |toSet(x)|
                              Context #1: |toSet(x)| = |conjure_aux1|
Picking the only option: Answer 1: set-card: Horizontal rule for set cardinality.
                                   sum([1 | q29 <- toSet(x)])
storedChoice:
|toSet(x)| 1897988597909520616
AnsweredRule {qHole_ = 1897988597909520616, qAscendants_ = fromList [-6188688663705288789,-5846429895491118400,361855989135376679,6530150935582701688,7219968226893579546,7779309324238844246], aRuleName_ = "set-card"}
LF:  {"AnsweredRule":{"aRuleName_":"set-card","qAscendants_":[-6188688663705288789,-5846429895491118400,361855989135376679,6530150935582701688,7219968226893579546,7779309324238844246],"qHole_":1897988597909520616}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([1 | q29 <- toSet(x)]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q29 <- toSet(x)]
                              Context #1: sum([1 | q29 <- toSet(x)])
Picking the only option: Answer 1: relation-map_in_expr{RelationAsMatrix}: Vertical rule for map_in_expr for relation domains, RelationAsMatrix representation.
                                   [1 | q30 : (int(1..5), int(1..5)), x_RelationAsMatrix[q30[1], q30[2]]]
storedChoice:
[1 | q29 <- toSet(x)] 7483192753320191769
AnsweredRule {qHole_ = 7483192753320191769, qAscendants_ = fromList [-7918094600437589284,-6091097458145320110,-4725927117271772380,-3818842550960350061,-801403655548510881,4177802111281067004,8691639764190092042], aRuleName_ = "relation-map_in_expr{RelationAsMatrix}"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-map_in_expr{RelationAsMatrix}","qAscendants_":[-7918094600437589284,-6091097458145320110,-4725927117271772380,-3818842550960350061,-801403655548510881,4177802111281067004,8691639764190092042],"qHole_":7483192753320191769}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([1 | q30 : (int(1..5), int(1..5)), x_RelationAsMatrix[q30[1], q30[2]]]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q30 : (int(1..5), int(1..5)), x_RelationAsMatrix[q30[1], q30[2]]]
                              Context #1: sum([1 | q30 : (int(1..5), int(1..5)), x_RelationAsMatrix[q30[1], q30[2]]])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q30 (with type: (int,
                                                                                                                                   int))
                                   [1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30[1], q30[2]]]
storedChoice:
[1 | q30 : (int(1..5), int(1..5)), x_RelationAsMatrix[q30[1], q30[2]]] -2219318056453463832
AnsweredRule {qHole_ = -2219318056453463832, qAscendants_ = fromList [-7631595452381029825,-6332648069028765836,-5599362277318624933,-1170492770147107149,188905738781826972,1046361987104095667,9181513732839926293], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-7631595452381029825,-6332648069028765836,-5599362277318624933,-1170492770147107149,188905738781826972,1046361987104095667,9181513732839926293],"qHole_":-2219318056453463832}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30[1], q30[2]]]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q30[1]
                              Context #1: x_RelationAsMatrix[q30[1]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q30[1]
                                   q30_1
storedChoice:
q30[1] 8985411351629801837
AnsweredRule {qHole_ = 8985411351629801837, qAscendants_ = fromList [-7287907811082918289,-3433749237930268197,-1514549063082826885,-254808116082235497,1395102958002486929,3724900484480857440,3763839719817425200,3764103551892886579,7098469255683427931,8809290278576126972], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-7287907811082918289,-3433749237930268197,-1514549063082826885,-254808116082235497,1395102958002486929,3724900484480857440,3763839719817425200,3764103551892886579,7098469255683427931,8809290278576126972],"qHole_":8985411351629801837}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30_1, q30[2]]]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q30[2]
                              Context #1: x_RelationAsMatrix[q30_1, q30[2]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q30[2]
                                   q30_2
storedChoice:
q30[2] 8986255815215080758
AnsweredRule {qHole_ = 8986255815215080758, qAscendants_ = fromList [-1904605123138931514,-1605383351683875510,-1500814072571245463,-1159370656118278861,-345152881798089093,3653718321561964858,5560045049720260591,6001294353827372355,7845034033468093823], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-1904605123138931514,-1605383351683875510,-1500814072571245463,-1159370656118278861,-345152881798089093,3653718321561964858,5560045049720260591,6001294353827372355,7845034033468093823],"qHole_":8986255815215080758}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30_1, q30_2]]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30_1, q30_2]]
                              Context #1: sum([1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30_1, q30_2]])
Picking the only option: Answer 1: inline-conditions: Inlining conditions, inside sum
                                   [toInt(x_RelationAsMatrix[q30_1, q30_2]) * catchUndef(1, 0) | q30_1 : int(1..5), q30_2 : int(1..5)]
storedChoice:
[1 | q30_1 : int(1..5), q30_2 : int(1..5), x_RelationAsMatrix[q30_1, q30_2]] 6730778895089912004
AnsweredRule {qHole_ = 6730778895089912004, qAscendants_ = fromList [-5543455485138138697,-1367499344277324489,-577770218778700729,3965135726409895025,4154476703970574900,4424005630299656964,8591791291160167043], aRuleName_ = "inline-conditions"}
LF:  {"AnsweredRule":{"aRuleName_":"inline-conditions","qAscendants_":[-5543455485138138697,-1367499344277324489,-577770218778700729,3965135726409895025,4154476703970574900,4424005630299656964,8591791291160167043],"qHole_":6730778895089912004}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) * catchUndef(1, 0) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: catchUndef(1, 0)
                              Context #1: [toInt(x_RelationAsMatrix[q30_1, q30_2]), catchUndef(1, 0); int(1..2)]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   1
storedChoice:
catchUndef(1, 0) -4103543015608659681
AnsweredRule {qHole_ = -4103543015608659681, qAscendants_ = fromList [-6246651641675555191,-4991494778996523170,-4841212563091249093,-3913142375130629094,-3482484897580979170,-192545505272530247,4617164660703414243,7663465281870587155,7888233777833351600,8484251082711739255], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-6246651641675555191,-4991494778996523170,-4841212563091249093,-3913142375130629094,-3482484897580979170,-192545505272530247,4617164660703414243,7663465281870587155,7888233777833351600,8484251082711739255],"qHole_":-4103543015608659681}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) * 1 | q30_1 : int(1..5), q30_2 : int(1..5)]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: toInt(x_RelationAsMatrix[q30_1, q30_2]) * 1
                              Context #1: [toInt(x_RelationAsMatrix[q30_1, q30_2]) * 1 | q30_1 : int(1..5), q30_2 : int(1..5)]
Picking the only option: Answer 1: partial-evaluate: Partial evaluator
                                   product([toInt(x_RelationAsMatrix[q30_1, q30_2]); int(1)])
storedChoice:
toInt(x_RelationAsMatrix[q30_1, q30_2]) * 1 -1687514346990485250
AnsweredRule {qHole_ = -1687514346990485250, qAscendants_ = fromList [-8383279591293107624,-5870374077749082103,-5035592936147091491,-3450507034164856240,-3171744958437112094,-148321104615195040,923428228047877070,2221664695150773241], aRuleName_ = "partial-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"partial-evaluate","qAscendants_":[-8383279591293107624,-5870374077749082103,-5035592936147091491,-3450507034164856240,-3171744958437112094,-148321104615195040,923428228047877070,2221664695150773241],"qHole_":-1687514346990485250}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([product([toInt(x_RelationAsMatrix[q30_1, q30_2]); int(1)]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: product([toInt(x_RelationAsMatrix[q30_1, q30_2]); int(1)])
                              Context #1: [product([toInt(x_RelationAsMatrix[q30_1, q30_2]); int(1)]) | q30_1 : int(1..5), q30_2 : int(1..5)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   toInt(x_RelationAsMatrix[q30_1, q30_2])
storedChoice:
product([toInt(x_RelationAsMatrix[q30_1, q30_2]); int(1)]) -601225972055529548
AnsweredRule {qHole_ = -601225972055529548, qAscendants_ = fromList [-7799870564036439127,-7432780384698737696,-6354763341195320334,-5508479272970515476,-2004497734168533005,1354218247559476283,3284517275149475981,4357080134642246606], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-7799870564036439127,-7432780384698737696,-6354763341195320334,-5508479272970515476,-2004497734168533005,1354218247559476283,3284517275149475981,4357080134642246606],"qHole_":-601225972055529548}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |conjure_aux1|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: |conjure_aux1|
                              Context #1: sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |conjure_aux1|
Picking the only option: Answer 1: relation-cardinality: Relation cardinality
                                   |toSet(conjure_aux1)|
storedChoice:
|conjure_aux1| 547691173299348338
AnsweredRule {qHole_ = 547691173299348338, qAscendants_ = fromList [-7326096647933004975,-3638343112521383479,-2681179249513342582,-1433468233918517477,416753721122881089,6250330639306929770], aRuleName_ = "relation-cardinality"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-cardinality","qAscendants_":[-7326096647933004975,-3638343112521383479,-2681179249513342582,-1433468233918517477,416753721122881089,6250330639306929770],"qHole_":547691173299348338}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |toSet(conjure_aux1)|,
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: |toSet(conjure_aux1)|
                              Context #1: sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = |toSet(conjure_aux1)|
Picking the only option: Answer 1: set-card: Horizontal rule for set cardinality.
                                   sum([1 | q31 <- toSet(conjure_aux1)])
storedChoice:
|toSet(conjure_aux1)| -1999756309500896427
AnsweredRule {qHole_ = -1999756309500896427, qAscendants_ = fromList [-7320026331482846196,-1560614952215100976,3610191966919989235,3922795876024111867,4652593413741964988,8460019197720106806], aRuleName_ = "set-card"}
LF:  {"AnsweredRule":{"aRuleName_":"set-card","qAscendants_":[-7320026331482846196,-1560614952215100976,3610191966919989235,3922795876024111867,4652593413741964988,8460019197720106806],"qHole_":-1999756309500896427}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) = sum([1 | q31 <- toSet(conjure_aux1)]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q31 <- toSet(conjure_aux1)]
                              Context #1: sum([1 | q31 <- toSet(conjure_aux1)])
Picking the only option: Answer 1: relation-map_in_expr{RelationAsMatrix}: Vertical rule for map_in_expr for relation domains, RelationAsMatrix representation.
                                   [1 | q32 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]]
storedChoice:
[1 | q31 <- toSet(conjure_aux1)] 4978495210772817269
AnsweredRule {qHole_ = 4978495210772817269, qAscendants_ = fromList [-7947851092910419335,-4272160902177458760,-654328132560036401,4133420425219294144,6369167416454940534,6390095031407007755,7113998651427981501], aRuleName_ = "relation-map_in_expr{RelationAsMatrix}"}
LF:  {"AnsweredRule":{"aRuleName_":"relation-map_in_expr{RelationAsMatrix}","qAscendants_":[-7947851092910419335,-4272160902177458760,-654328132560036401,4133420425219294144,6369167416454940534,6390095031407007755,7113998651427981501],"qHole_":4978495210772817269}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([1 | q32 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q32 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]]
                              Context #1: sum([1 | q32 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q32 (with type: (int,
                                                                                                                                   int))
                                   [1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]]
storedChoice:
[1 | q32 : (int(1..5), int(1..5)), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]] 3282965607985773269
AnsweredRule {qHole_ = 3282965607985773269, qAscendants_ = fromList [-7122899784982260955,-5889198071192861072,-531055723096273851,147713573061616732,2477913925342540157,3767703974941705567,9091983968002426702], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-7122899784982260955,-5889198071192861072,-531055723096273851,147713573061616732,2477913925342540157,3767703974941705567,9091983968002426702],"qHole_":3282965607985773269}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32[1], q32[2]]]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q32[1]
                              Context #1: conjure_aux1_RelationAsMatrix[q32[1]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q32[1]
                                   q32_1
storedChoice:
q32[1] 4038868374035555703
AnsweredRule {qHole_ = 4038868374035555703, qAscendants_ = fromList [-8553658543572221773,-6138711856874023512,-4335853381078465244,-2646146961819662754,-2343456358494450273,-1664802311461525085,-1649342081664357811,3161695419280017087,3741265834386353390,8703630850884516346], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[-8553658543572221773,-6138711856874023512,-4335853381078465244,-2646146961819662754,-2343456358494450273,-1664802311461525085,-1649342081664357811,3161695419280017087,3741265834386353390,8703630850884516346],"qHole_":4038868374035555703}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32_1, q32[2]]]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: q32[2]
                              Context #1: conjure_aux1_RelationAsMatrix[q32_1, q32[2]]
Picking the only option: Answer 1: tuple-index: Tuple indexing on: q32[2]
                                   q32_2
storedChoice:
q32[2] 4038586886173796060
AnsweredRule {qHole_ = 4038586886173796060, qAscendants_ = fromList [58246981470148902,365936135746281162,897915292494521279,2148255109439096362,2599338170801596327,4347596293011070033,8156974448309241515,8375135551163386670,8976994852842826417], aRuleName_ = "tuple-index"}
LF:  {"AnsweredRule":{"aRuleName_":"tuple-index","qAscendants_":[58246981470148902,365936135746281162,897915292494521279,2148255109439096362,2599338170801596327,4347596293011070033,8156974448309241515,8375135551163386670,8976994852842826417],"qHole_":4038586886173796060}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32_1, q32_2]]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32_1, q32_2]]
                              Context #1: sum([1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32_1, q32_2]])
Picking the only option: Answer 1: inline-conditions: Inlining conditions, inside sum
                                   [toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * catchUndef(1, 0) | q32_1 : int(1..5), q32_2 : int(1..5)]
storedChoice:
[1 | q32_1 : int(1..5), q32_2 : int(1..5), conjure_aux1_RelationAsMatrix[q32_1, q32_2]] -5719405584779695493
AnsweredRule {qHole_ = -5719405584779695493, qAscendants_ = fromList [-9027745215861162370,-8099216132366058965,-5857000228242749317,-5553782237459419472,4623787234387693138,7124000196337888585,8079567542521963183], aRuleName_ = "inline-conditions"}
LF:  {"AnsweredRule":{"aRuleName_":"inline-conditions","qAscendants_":[-9027745215861162370,-8099216132366058965,-5857000228242749317,-5553782237459419472,4623787234387693138,7124000196337888585,8079567542521963183],"qHole_":-5719405584779695493}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * catchUndef(1, 0) | q32_1 : int(1..5), q32_2 : int(1..5)]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: catchUndef(1, 0)
                              Context #1: [toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]), catchUndef(1, 0); int(1..2)]
Picking the only option: Answer 1: full-evaluate: Full evaluator
                                   1
storedChoice:
catchUndef(1, 0) -4103543015608659681
AnsweredRule {qHole_ = -4103543015608659681, qAscendants_ = fromList [-8969688714663757079,-8620054688580705850,-7803342152587091485,-6406402188841036454,-3137912990386087120,-2245754891843782432,-893701506107809144,-421079377584717971,4859060653783625533,9081980220064719370], aRuleName_ = "full-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"full-evaluate","qAscendants_":[-8969688714663757079,-8620054688580705850,-7803342152587091485,-6406402188841036454,-3137912990386087120,-2245754891843782432,-893701506107809144,-421079377584717971,4859060653783625533,9081980220064719370],"qHole_":-4103543015608659681}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * 1 | q32_1 : int(1..5), q32_2 : int(1..5)]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * 1
                              Context #1: [toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * 1 | q32_1 : int(1..5), q32_2 : int(1..5)]
Picking the only option: Answer 1: partial-evaluate: Partial evaluator
                                   product([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]); int(1)])
storedChoice:
toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) * 1 -4682469706785037945
AnsweredRule {qHole_ = -4682469706785037945, qAscendants_ = fromList [-9179050654683062954,-8797033748133430528,-8329454991333631126,-5647606918064816013,-3380861767487578940,6010365049512866508,6747419370843152779,7119833088853932687], aRuleName_ = "partial-evaluate"}
LF:  {"AnsweredRule":{"aRuleName_":"partial-evaluate","qAscendants_":[-9179050654683062954,-8797033748133430528,-8329454991333631126,-5647606918064816013,-3380861767487578940,6010365049512866508,6747419370843152779,7119833088853932687],"qHole_":-4682469706785037945}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([product([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]); int(1)]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: product([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]); int(1)])
                              Context #1: [product([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]); int(1)]) | q32_1 : int(1..5), q32_2 : int(1..5)]
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2])
storedChoice:
product([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]); int(1)]) -3618757702268377732
AnsweredRule {qHole_ = -3618757702268377732, qAscendants_ = fromList [-3180788541249390624,-1419697389512850335,2051112281511221751,3011082682326874338,4702464191332467431,4730858055169822202,6821954100224183740,8108702534288021537], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[-3180788541249390624,-1419697389512850335,2051112281511221751,3011082682326874338,4702464191332467431,4730858055169822202,6821954100224183740,8108702534288021537],"qHole_":-3618757702268377732}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                         sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
                         and([x_RelationAsMatrix[q8_1, q8_2] ->
                              or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                      | q28_1 : int(1..5), q28_2 : int(1..5)])
                                  | q8_1 : int(1..5), q8_2 : int(1..5)]);
                             int(1..2)]
                      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                        such that
                            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            },
                            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                              such that
                                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                            }
                      })
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                             sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
                                             and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                  or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                          | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                      | q8_1 : int(1..5), q8_2 : int(1..5)]);
                                                 int(1..2)]
                                          @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                            such that
                                                { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                },
                                                { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                           (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                               | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                }
                                          })
                              Context #1: { conjure_aux1
                                          @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                            such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                            such that
                                                and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                                       sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
                                                       and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                            or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                                    | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                                | q8_1 : int(1..5), q8_2 : int(1..5)]);
                                                           int(1..2)]
                                                    @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                      find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                      such that
                                                          { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                          @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                            such that
                                                                and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                                     (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                         | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                          },
                                                          { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                          @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                            such that
                                                                and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                                     (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                         | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                          }
                                                    })
                                          }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                     sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                                     /\
                                     and([x_RelationAsMatrix[q8_1, q8_2] ->
                                          or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                  | q28_1 : int(1..5), q28_2 : int(1..5)])
                                              | q8_1 : int(1..5), q8_2 : int(1..5)])
                                   @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                     such that
                                         { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         },
                                         { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                    (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                        | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         }
                                   }
storedChoice:
and({ [sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
       sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
       and([x_RelationAsMatrix[q8_1, q8_2] ->
            or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                    | q28_1 : int(1..5), q28_2 : int(1..5)])
                | q8_1 : int(1..5), q8_2 : int(1..5)]);
           int(1..2)]
    @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
      such that
          { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
          @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
            such that
                and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                     (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
          },
          { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
          @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
            such that
                and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                     (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
          }
    }) -4558336889735046944
AnsweredRule {qHole_ = -4558336889735046944, qAscendants_ = fromList [-3486949521822083211,2980043443155673363], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[-3486949521822083211,2980043443155673363],"qHole_":-4558336889735046944}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            y =
            { conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: y =
                                      { conjure_aux1
                                      @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                        such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                        such that
                                            { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                              sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                                              /\
                                              and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                   or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                           | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                                            @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                              find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                              such that
                                                  { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                  @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                    such that
                                                        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                 | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                  },
                                                  { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                  @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                    such that
                                                        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                 | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                  }
                                            }
                                      }
Picking the only option: Answer 1: bubble-up-LiftVars: Bubbling up auxiliary variables.
                                   { y = conjure_aux1
                                   @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                     such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                     such that
                                         { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                           sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                                           /\
                                           and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                        | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                    | q8_1 : int(1..5), q8_2 : int(1..5)])
                                         @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                           such that
                                               { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                               @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                 such that
                                                     and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                          (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                              | q8_1 : int(1..5), q8_2 : int(1..5)])
                                               },
                                               { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                               @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                 such that
                                                     and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                          (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                              | q8_1 : int(1..5), q8_2 : int(1..5)])
                                               }
                                         }
                                   }
storedChoice:
y =
{ conjure_aux1
@ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
  such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
  such that
      { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
      @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
        find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
        such that
            { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
            @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
              such that
                  and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                       (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                           | q8_1 : int(1..5), q8_2 : int(1..5)])
            },
            { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
            @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
              such that
                  and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                       (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                           | q8_1 : int(1..5), q8_2 : int(1..5)])
            }
      }
} 8908675996089062110
AnsweredRule {qHole_ = 8908675996089062110, qAscendants_ = fromList [], aRuleName_ = "bubble-up-LiftVars"}
LF:  {"AnsweredRule":{"aRuleName_":"bubble-up-LiftVars","qAscendants_":[],"qHole_":8908675996089062110}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { y = conjure_aux1
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: y = conjure_aux1
                              Context #1: { y = conjure_aux1
                                          @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                            such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                            such that
                                                { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                                  sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                                                  /\
                                                  and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                       or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                               | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                        such that
                                                            and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                                 (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      },
                                                      { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                        such that
                                                            and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                                 (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      }
                                                }
                                          }
Picking the only option: Answer 1: identical-domain-eq: Generic vertical rule for identical-domain equality
                                   and([y_RelationAsMatrix = conjure_aux1_RelationAsMatrix; int(1)])
storedChoice:
y = conjure_aux1 3717099060101766216
AnsweredRule {qHole_ = 3717099060101766216, qAscendants_ = fromList [2671848414499686108], aRuleName_ = "identical-domain-eq"}
LF:  {"AnsweredRule":{"aRuleName_":"identical-domain-eq","qAscendants_":[2671848414499686108],"qHole_":3717099060101766216}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([y_RelationAsMatrix = conjure_aux1_RelationAsMatrix; int(1)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: y_RelationAsMatrix = conjure_aux1_RelationAsMatrix
                              Context #1: [y_RelationAsMatrix = conjure_aux1_RelationAsMatrix; int(1)]
Picking the only option: Answer 1: matrix-eq: Horizontal rule for matrix =
                                   and([y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)])
storedChoice:
y_RelationAsMatrix = conjure_aux1_RelationAsMatrix 847538541028825252
AnsweredRule {qHole_ = 847538541028825252, qAscendants_ = fromList [-7545604584042643741,-3140704007737949652,8589500105863926587], aRuleName_ = "matrix-eq"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-eq","qAscendants_":[-7545604584042643741,-3140704007737949652,8589500105863926587],"qHole_":847538541028825252}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)]); int(1)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)]
                              Context #1: and([y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q33 (with type: int)
                                   [y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)]
storedChoice:
[y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)] 45103260545151270
AnsweredRule {qHole_ = 45103260545151270, qAscendants_ = fromList [-5973861858959396663,-4660253290178341140,-3962474706459959320,-1163992588452778161], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-5973861858959396663,-4660253290178341140,-3962474706459959320,-1163992588452778161],"qHole_":45103260545151270}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)]); int(1)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33]
                              Context #1: [y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] | q33 : int(1..5)]
Picking the only option: Answer 1: matrix-eq: Horizontal rule for matrix =
                                   and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)])
storedChoice:
y_RelationAsMatrix[q33] = conjure_aux1_RelationAsMatrix[q33] 971298532972344754
AnsweredRule {qHole_ = 971298532972344754, qAscendants_ = fromList [-5973861858959396663,-4660253290178341140,-3962474706459959320,-1163992588452778161,45103260545151270], aRuleName_ = "matrix-eq"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-eq","qAscendants_":[-5973861858959396663,-4660253290178341140,-3962474706459959320,-1163992588452778161,45103260545151270],"qHole_":971298532972344754}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)]);
                       int(1)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: [y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]
                              Context #1: and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)])
Picking the only option: Answer 1: choose-repr-for-comprehension: Choosing representation for quantified variable q35 (with type: int)
                                   [y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]
storedChoice:
[y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)] -1275491152285478671
AnsweredRule {qHole_ = -1275491152285478671, qAscendants_ = fromList [-9124538447972763747,1151872964749555522,2218928338283019637,3574995822047355118,8452562685486794942,8526913528687567140], aRuleName_ = "choose-repr-for-comprehension"}
LF:  {"AnsweredRule":{"aRuleName_":"choose-repr-for-comprehension","qAscendants_":[-9124538447972763747,1151872964749555522,2218928338283019637,3574995822047355118,8452562685486794942,8526913528687567140],"qHole_":-1275491152285478671}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)]);
                       int(1)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: and([and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35]
                                                         | q35 : int(1..5)])
                                                    | q33 : int(1..5)]);
                                               int(1)])
                              Context #1: { and([and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)])
                                                          | q33 : int(1..5)]);
                                                     int(1)])
                                          @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
                                            such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
                                            such that
                                                { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                                                  sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                                                  /\
                                                  and([x_RelationAsMatrix[q8_1, q8_2] ->
                                                       or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                                               | q28_1 : int(1..5), q28_2 : int(1..5)])
                                                           | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                  such that
                                                      { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                        such that
                                                            and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                                                 (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      },
                                                      { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                                                        such that
                                                            and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                                                 (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                                                     | q8_1 : int(1..5), q8_2 : int(1..5)])
                                                      }
                                                }
                                          }
Picking the only option: Answer 1: matrix-comprehension-singleton: Removing quantifier of a single item
                                   and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
storedChoice:
and([and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)]);
         int(1)]) 3574995822047355118
AnsweredRule {qHole_ = 3574995822047355118, qAscendants_ = fromList [1151872964749555522], aRuleName_ = "matrix-comprehension-singleton"}
LF:  {"AnsweredRule":{"aRuleName_":"matrix-comprehension-singleton","qAscendants_":[1151872964749555522],"qHole_":3574995822047355118}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true(x),
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: true(x)
Picking the only option: Answer 1: true-is-noop: Remove the argument from true.
                                   true
storedChoice:
true(x) -1508832156878423928
AnsweredRule {qHole_ = -1508832156878423928, qAscendants_ = fromList [], aRuleName_ = "true-is-noop"}
LF:  {"AnsweredRule":{"aRuleName_":"true-is-noop","qAscendants_":[],"qHole_":-1508832156878423928}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true,
            true(y)
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
Picking the first option: Question 1: true(y)
Picking the only option: Answer 1: true-is-noop: Remove the argument from true.
                                   true
storedChoice:
true(y) -1508550667338902379
AnsweredRule {qHole_ = -1508550667338902379, qAscendants_ = fromList [], aRuleName_ = "true-is-noop"}
LF:  {"AnsweredRule":{"aRuleName_":"true-is-noop","qAscendants_":[],"qHole_":-1508550667338902379}} END:
[loopy] language Essence 1.3
        
        letting p be permutation((3, 4))
        find x: relation (size 4) of (int(1..5) * int(1..5))
        find y: relation (size 4) of (int(1..5) * int(1..5))
        such that
            { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
            @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
              such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
              such that
                  { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                    sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                    /\
                    and([x_RelationAsMatrix[q8_1, q8_2] ->
                         or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                                 | q28_1 : int(1..5), q28_2 : int(1..5)])
                             | q8_1 : int(1..5), q8_2 : int(1..5)])
                  @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                    such that
                        { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        },
                        { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                        @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                          such that
                              and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                                   (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                       | q8_1 : int(1..5), q8_2 : int(1..5)])
                        }
                  }
            }
        branching on [x, y]
        such that
        such that
            true,
            true
        such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
        such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
        
[epilogue]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that
        { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
        @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
          such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
          such that
              { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                /\
                and([x_RelationAsMatrix[q8_1, q8_2] ->
                     or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                             | q28_1 : int(1..5), q28_2 : int(1..5)])
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
              @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                such that
                    { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    },
                    { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    }
              }
        }
    branching on [x, y]
    such that
    such that
        true,
        true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[dropTagForSR]
    language Essence 1.3
    
    letting p be permutation((3, 4))
    find x: relation (size 4) of (int(1..5) * int(1..5))
    find y: relation (size 4) of (int(1..5) * int(1..5))
    such that
        { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
        @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
          such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
          such that
              { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                /\
                and([x_RelationAsMatrix[q8_1, q8_2] ->
                     or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                             | q28_1 : int(1..5), q28_2 : int(1..5)])
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
              @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                such that
                    { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    },
                    { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    }
              }
        }
    branching on [x, y]
    such that
    such that
        true,
        true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[updateDeclarations]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that
        { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
        @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
          such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
          such that
              { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                /\
                and([x_RelationAsMatrix[q8_1, q8_2] ->
                     or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                             | q28_1 : int(1..5), q28_2 : int(1..5)])
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
              @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                such that
                    { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    },
                    { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    }
              }
        }
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that
    such that
        true,
        true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[inlineDecVarLettings]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that
        { and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
        @ find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
          such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
          such that
              { sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
                sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
                /\
                and([x_RelationAsMatrix[q8_1, q8_2] ->
                     or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                             | q28_1 : int(1..5), q28_2 : int(1..5)])
                         | q8_1 : int(1..5), q8_2 : int(1..5)])
              @ find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                such that
                    { and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    },
                    { and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
                    @ find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
                      such that
                          and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
                               (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                                   | q8_1 : int(1..5), q8_2 : int(1..5)])
                    }
              }
        }
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that
    such that
        true,
        true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[topLevelBubbles]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[checkIfAllRefined]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[checkIfHasUndefined]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[sliceThemMatrices]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[emptyMatrixLiterals]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[reverseTrails]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    such that 4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)])
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    such that
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)])
        /\
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)])
    such that and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)])
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that true
    such that true
    such that 4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)])
    such that 4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[oneSuchThat]
    language Essence 1.3
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that
        4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)]),
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]),
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)]),
        4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)]),
        4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
[languageEprime]
    language ESSENCE' 1.0
    
    find x_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find y_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux1_RelationAsMatrix: matrix indexed by [int(1..5), int(1..5)] of bool
    find conjure_aux2_1: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux2_2: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux3: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    find conjure_aux4: matrix indexed by [int(1..5), int(1..5)] of int(1..5)
    branching on [x_RelationAsMatrix, y_RelationAsMatrix]
    such that
        4 = sum([sum([toInt(conjure_aux1_RelationAsMatrix[q6, q7]) | q7 : int(1..5)]) | q6 : int(1..5)]),
        and([(3 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 4) /\ (4 = q8_1 <-> conjure_aux3[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux3[q8_1, q8_2] \/ 4 = conjure_aux3[q8_1, q8_2]) <-> conjure_aux3[q8_1, q8_2] = q8_1)
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([conjure_aux2_1[q8_1, q8_2] = conjure_aux3[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([(3 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 4) /\ (4 = q8_2 <-> conjure_aux4[q8_1, q8_2] = 3) /\
             (!(3 = conjure_aux4[q8_1, q8_2] \/ 4 = conjure_aux4[q8_1, q8_2]) <-> conjure_aux4[q8_1, q8_2] = q8_2)
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([conjure_aux2_2[q8_1, q8_2] = conjure_aux4[q8_1, q8_2] | q8_1 : int(1..5), q8_2 : int(1..5)]),
        sum([toInt(x_RelationAsMatrix[q30_1, q30_2]) | q30_1 : int(1..5), q30_2 : int(1..5)]) =
        sum([toInt(conjure_aux1_RelationAsMatrix[q32_1, q32_2]) | q32_1 : int(1..5), q32_2 : int(1..5)]),
        and([x_RelationAsMatrix[q8_1, q8_2] ->
             or([conjure_aux1_RelationAsMatrix[q28_1, q28_2] /\ (q28_1 = conjure_aux2_1 /\ q28_2 = conjure_aux2_2)
                     | q28_1 : int(1..5), q28_2 : int(1..5)])
                 | q8_1 : int(1..5), q8_2 : int(1..5)]),
        and([and([y_RelationAsMatrix[q33, q35] = conjure_aux1_RelationAsMatrix[q33, q35] | q35 : int(1..5)]) | q33 : int(1..5)]),
        4 = sum([sum([toInt(x_RelationAsMatrix[q1, q2]) | q2 : int(1..5)]) | q1 : int(1..5)]),
        4 = sum([sum([toInt(y_RelationAsMatrix[q3, q4]) | q4 : int(1..5)]) | q3 : int(1..5)])
    
